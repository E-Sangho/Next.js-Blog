---
title: REST API
date: 2022-12-01 16:12:44
category: CS
tag: [Javascript, React, Python, Django]
excerpt: ""
cover_image: /images/posts/networking.jpg
draft: true
---

## REST API

웹 공부를 하면서 REST API라는 말을 종종 들었다.
그동안은 대충 정해진 URL에 HTTP 메소드를 사용해 소통하는 방법 정도로 이해하고 있었다.
REST가 무엇인지 잘 이해하지 못하다보니, 제대로 REST를 따르고 있는지 알 수 없어서 이번 기회에 제대로 정리해봤다.
추천하는 영상으로 [그런 REST API로 괜찮은가?](https://www.youtube.com/watch?v=RP_f5dMoHFc)를 보기를 권한다.
설명이 굉장히 깔끔하고 이해하기 쉽게 구성되어 있다.

### API

나는 친구들과 종종 카페에 가는 편인데, 단 음료를 좋아해서 카라멜 마끼아또를 시키곤 한다.
그 후 자리를 잡고 친구들과 얘기를 나누다가 음료가 나오면 거기에 빨대를 꽂아 마신다.
아마 이 글을 보자마자 각자가 카페에서 음료를 마시는 모습이 떠올랐을 것이다.
이때 뒤에서 바리스타가 커피를 어떻게 만드는지 관심을 가져본적이 있는가?
나는 별로 그런적이 없는 것 같다.
사람은 이처럼 어떻게 그 음료가 만들어졌는지 크게 관심을 가지지 않는다.
왜냐하면 직접 재료를 준비하고 만드는 과정이 번거롭기도하고, 만드는 모습에 별 관심이 없기 때문이다.
사람들은 그저 음료에 빨대를 꽂아 맛있게 먹는 것만 신경쓴다.
내가 이런 예기를 한 이유는 API가 빨대와 다름 없기 때문이다.
빨대는 남이 만들어둔 맛있는 음료를 별다른 고생 없이 먹기 위한 도구다.
마찬가지로 API는 누군가 고생해가며 만든 기능의 달콤한 결과물만 가져온다.
이게 무슨 의민지는 차차 설명하기로 하고 지금은 API는 빨대라는 것만 기억하자.

API는 Application Programming Interface의 약자다.
여기서 Interface가 무엇인지 살펴보자.
한국 사람이 아랍 사람과 만난다면 당연하게 의사소통이 안 된다.
둘이 대화하려면 어쩔 수 없이 통역사를 고용해야만 한다.
Interface는 이처럼 둘 사이에서 소통이 가능하도록 만들어주는 장치를 말한다.
예를 들어 사람이 컴퓨터에게 명령하기 위해선 키보드와 마우스가 필요한데, 키보드와 마우스가 대표적인 인터페이스다.
여기서 인터페이스는 하드웨어 장치 뿐만 아니라 소프트웨어적 개념도 포함한다.
소프트웨어 사이의 인터페이스는 여러 종류가 있지만, 그 중에서도 대표적인 예가 애플리케이션 사이의 인터페이스 다시 말해 API다.

API가 애플리케이션 사이에 소통할 수 있게 해주는 코드라는 사실은 알았다.
그런데 구체적으로 API가 왜 필요하며 어떤 일을 해주길래 소통하게 해준다는 것일까?
각 지역별 날씨를 알려주는 애플리케이션을 만들고 싶다고 하자.
그러면 우리는 각 지역마다 날씨 측정용 장비를 설치하고, 그 내용을 전송할 회선을 만들고, 측정값을 저장할 서버를 만들고, 또 이 내용을 가져와서 코드를 작성하는 등 해야할 일이 끝없이 늘어나게 된다.
단지 우리는 날씨를 알고 싶을 뿐인데 투자해야하는 돈과 시간이 무지막지해서 도저히 불가능하다.
그런데 이미 우리나라엔 기상청이라는 날씨를 측정하는 기관이 있다.
얌체같지만 복잡한 일은 모두 기상청에게 떠넘기고, 그 결과만을 편하게 쓸 수 있다면 좋을 것이다.
다시 말해 기상청이 만들어 놓은 꿀 같은 정보를 빨대로 빨아먹고 싶은 것이다.
우리가 기상청의 데이터를 가져오려면 기상청이 날씨 정보를 가져갈 수 있는 인프라를 만들어야 가능하고, 이 인프라가 바로 기상청 날씨 API다.
이로 인해 복잡한 일은 기상청에서 하고 우리는 API를 통해서 그 결과만을 받아오는 것이다.
정리하자면 API는 프로그래머가 직접하기 힘든 일을 처리할 때 사용된다.
해당 일을 위임하기도 하고 저장된 내용을 가져오기도 하는데, 그 사이에서 코드로 간결하게 호출할 수 있도록 만든 것이 API다.

API와 라이브러리가 비교되곤 하는데 둘은 다른 개념이다.
라이브러리는 재사용할 코드를 묶음으로 만들어 다음에도 쓰기 쉽게 만든 것이고, API는 다른 대상과 소통하기 위한 기능이다.
비유적으로 표현하자면 라이브러리는 상품이고 API는 통신 기술이다.
우리 주변엔 많은 상품이 있는데, 예를 들어 전화기, 축구공, 자동차 등이 있다.
이들은 공장에서 만들어서 일괄적으로 동일한 서비스를 제공하고 A 축구공과 B 축구공은 다른 점이 없다.
이중 휴대폰, 컴퓨터 같은 몇몇 상품은 통신 기술이 들어 있어서 다른 사람과 소통하는데 쓸 수 있다.
그런데 상품과 통신 기술은 전혀 다른 것이다.
일부 상품에 통신 기술이 들어 있긴 하지만 포함관계도 아닌 것이다.
API는 두 애플리케이션 사이에서 소통하게 해주는 코드다.
라이브러리는 여러 코드를 묶은 것으로 그 안에서 API를 호출하는 경우도 있지만 아닌 경우도 있다.

### REST

인터넷이 생겨남으로써 사람들은 어떻게 인터넷으로 정보를 공유할지 고민하게 되었다.
그 결과물로 이메일, 토렌트, 게임 등이 인터넷을 사용하지만, 그 중에서 가장 큰 성공을 거둔 것은 웹이다.
그렇다면 웹은 어떻게 그렇게 큰 성공을 거둘 수 있었을까?
정보를 보여줄 때 중요한 것은 어떤 것을 보여줄 것인가 뿐만 아니라, 정보를 어떻게 연결할지다.
웹은 각 정보를 링크로 연결해준다.
덕분에 모르는 내용이 생기거나 다른 내용을 읽고 싶으면 링크를 클릭하는 것만으로 간단하게 해당 정보를 볼 수 있다.
이는 굉장한 점인데, 예를 들어 책은 중간에 모르는 단어가 생겨도 해당 내용을 찾을 수 없고, 이메일 또한 내용이 적혀 있기만 할 뿐 다른 이메일과 연결되지 않는다.
웹에선 이 링크를 하이퍼 텍스트라고 하는데, 기존의 앞뒤로 이어지는 텍스트가 아니라 서로를 건너다닐 수 있는 텍스트라는 의미다.

웹이 하이퍼 텍스트를 사용한다는 사실을 알았지만 아직 남은 문제가 있다.
어떻게 하이퍼 텍스트를 표시할지, 정보를 어떻게 식별할지, 그리고 어떻게 전송할지다.
하이퍼 텍스트를 표시하기 위해 HTML(Hyper Text Markup Language)을 사용한다.
여기서 HT가 하이퍼 텍스트인것은 알겠는데, 뒤의 Markup Language는 무엇일까?
마크업 언어는 태그를 사용해 구조를 표시하는 언어다.
다시 말해 제목, 리스트, 메타 데이터, 링크 등의 구조를 앞뒤로 태그를 사용해 표시하는 언어다.
그렇기 때문에 HTML이 앞뒤로 태그를 사용하는 것이다.

다음으로 각 정보를 어떻게 식별할지다.
책은 각 페이지마다 정해진 정보가 적혀있다.
마찬가지로 웹에서도 같은 페이지를 찾을 방법이 필요했고 이를 URI(Uniform Resource Identifier)라고 한다.
URI는 그 이름에서 볼 수 있듯이 각 정보마다 id를 줘서 대상을 일정하게 찾을 수 있게 고안되었다.
우리 일상에서 가장 쉽게 볼 수 있는 URI는 URL로, 프로토콜, 호스트, 경로, 쿼리를 사용해서 각 리소스를 구분한다.

마지막으로 전송 방법은 HTTP 프로토콜을 사용한다.
이에 관한 자세한 얘기는 네트워크 과목에서 다루겠다.
정리하자면 웹은 아래의 3가지로 구성된다.

- 표현형식: HTML
- 식별자: URI
- 전송 방법: HTTP

그러던중 Roy Fielding이란 사람이 HTTP 작업에 참여하게 되면서 고민이 생겼다.
HTTP에 새로운 기능을 추가하거나 삭제하려면 업데이트가 필요하다.
문제는 HTTP를 고치면 기존에 사용하던 웹과 호환성 문제가 발생할 수 있다.
그래서 Roy Fielding은 어떻게 웹은 망가뜨리지 않고 만들 수 있을지 연구했다.
즉, 유지보수시에 문제가 생기지 않을 구조를 고민한 것이다.
이 생각은 이후에 정리되어 박사 논문으로 발표되는데 이것이 바로 REST다.

REST(Representational State Transfer)는 네트워크 통신시 지켜야할 규칙을 정리한 것이다.
물론 웹 역시 네트워크의 일부이므로 웹에도 적용되는 사항이다.
아래는 REST의 원칙이다.

- Client/Server
- Stateless
- Cacheable
- Layered System
- Uniform Interface
- Code on demand(optional)

하얀 백지 상태에서 프로그램을 작성하다보면 내가 잘 만들고 있는지 고민되는 순간이 있다.
아무런 기준점 없이 하다보니, 스스로 피드백도 잘 안 되고, 앞으로 어떤 것이 필요한지 알 수가 없다.
이처럼 우리는 코드를 작성할때 막대한 자유를 누리지만, 이로 인해 헤메는 경우가 많다.
그래서 몇 가지 규칙을 만들어서 내가 가능 방향이 맞는지 확인할 필요가 있다.
REST는 그 중에서도 유지보수를 편하게 하기 위한 원칙이다.
앞으로 우리는 위 규칙이 추가됨으로써 왜 유지보수하기 좋은 코드가 작성되는지 살펴볼 것이다.

#### Client-Server

우선은 아무런 규칙이 없는 상태에서 시작해보자.
가장 먼저 추가되어야 할 조건은 클라이언트-서버 구조로 나누는 것이다.
이미 이 스타일은 대부분의 회사에서 채택하고 있으므로 당연하게 여겨질 것이다.
그렇지만 우리는 이 규칙을 처음 만든 순간을 생각해야 한다.
초창기 컴퓨터는 특정 시설에서만 쓰이는 장비로 그 시스템을 분산할 필요가 없었다.
그러다가 인터넷이 생기면서 사용자에게 보이는 부분인 클라이언트 측과, 자원을 관리하는 서버로 나뉘게 되었다.
모든 자원은 서버 한 장소에서만 관리하니 수정이 용이했고, 클라이언트 역시 자원을 어떻게 보여줄지만 신경쓰면 된다.

클라이언트-서버 구조로 나뉘면서 목표에 따라 코드를 나눠서 작성할 수 있게 됐다.
그런데 클라이언트와 서버는 각자 어떤 것을 목표로 해야 할까?
클라이언트는 가급적 많은 사용자가 쓸 수 있어야 하므로, 다양한 환경에서 널리 쓰이게 발전했다.
예를 들어 웹 페이지를 생각해보자.
웹 페이지는 크롬, 사파리, 파이어 폭스 등 어떤 브라우저를 사용해도 정상적으로 동작한다.
또한 PC, 스마트폰, 태블릿 등 어떤 장비든 관계 없이 같은 웹 페이지를 보여준다.
이처럼 다양한 환경에서 작동하는 것을 *이식성(protability)*이라고 하며, 클라이언트는 이식성이 높게 만들어졌다.
이런 특성을 당연하게 생각할 순 있지만, 스마트폰 앱을 생각하면 그렇지 않다.
스마트폰 앱은 os에 따라 다른 언어로 작성해야 하며, 각자 특정 스마트폰에서만 동작하며, PC나 태블릿에서 쓸 수 없을 때도 많다.
웹 브라우저가 이식성이 높은 것은 그런 방향으로 발전했기 때문이라는 것을 기억하자.

서버는 업데이트 되면서 여러 기능이 추가되기 마련이다.
그런데 서버에 기능이 추가될 때마다 클라이언트에 문제가 생기면 코드 작성에 많은 어려움이 있을 것이다.
그러므로 서버는 새로운 코드가 추가되어도 문제 없는 구조로 만들어졌는데 이를 *확장성*이라 한다.
브라우저를 예시로 들어보자.
만약 서버가 잘못된 정보를 주거나 깨진 정보를 준다면, 브라우저에서 보이는 내용 역시 이상할 것이다.
그렇지만 브라우저가 꺼진다거나 클릭, 입력 같은 기능을 수행하지 못하는 등의 문제는 발생하지 않는다.
문제가 발생했을 땐 서버만 제대로 고치면 정상적으로 작동하는 것이다.
서버에 새로운 기능을 추가해도 브라우저의 기능엔 아무런 영향을 주지 않고 브라우저는 업데이트 해야할 필요가 없다.
가령 서버가 새로운 버전을 출시해도, 브라우저를 업데이트 해야하는 경우는 없다.
이처럼 서버 코드를 아무리 수정해도 브라우저에서 문제가 생길 일이 없으므로 서버는 확장성이 높다.
반면 금융 앱을 생각해보자.
금융 앱들은 대부분 서버에서 업데이트가 이뤄지면, 애플리케이션도 같이 업데이트해야 하는 경우가 많다.
브라우저와 달리 서버 기능 추가에 따라 애플리케이션 구조를 바꿔야 하기 때문이다.

#### Stateless

REST는 Representational State Transfer의 약자라고 했었다.
여기서 Representation, State가 무엇인지 설명하지 않고 지나갔었는데, stateless를 설명하기 전에 필요한 개념이라 여기서 소개하겠다.
자원(Resource)은 정보를 담고 있는 모든 것으로 이미지, 텍스트 파일, 비디오, HTML 페이지 등 모든 것이 될 수 있다.
그런데 자원은 추상적인 개념일뿐 다른 매체에서 사용할 수가 없다.
무슨 뜻인지 알기 위해 아래 같은 정보가 있다고 하자.

```
user
  id: 1
  name: Alice
  email: email@gmail.com
```

위 내용만 보고도 사람은 어떤 내용인지 알 수 있지만, 컴퓨터는 위 내용을 제대로 이해하지 못한다.
그러므로 특정 형식에 따라 데이터를 표현해야 하는데, 예를 들어 아래처럼 표시할 수 있겠다.

```
<user>
  <id>1</id>
  <name>Alice</name>
  <email>email@gmail.com</email>
</user>

or

{
  "id": 1,
  "name": "Alice",
  "email": "email@gmail.com",
}
```

위의 2가지는 XML과 JSON으로 데이터를 적은 것이다.
이처럼 자원은 각각을 표시하는 방법이 필요하다.
이를 Representation이라 하며, Representation은 결국 어떤 포맷으로 데이터를 표시할지 정하는 것이다.

state는 컴퓨터를 공부하다보면 여러 곳에서 등장하는 단어다.
application state, resource state, session state, router state, stateless 등 온갖 내용에 사용된다.
그런데 state가 무엇인지 구체적으로 설명하는 글은 찾기 힘들다.
아무래도 다양한 의미로 사용되기도 하고, state 자체가 감각적으로 뜻을 알 수 있어서 그런듯 하다.
이 기회에 state가 무엇인지 설명하겠다.
state는 상태라는 뜻이고 그래서 많은 사람들이 상태라고 번역한다.
그런데 상태란 무엇일까?
네트워크 통신시에는 통신 중, 시작, 실패 등을 의미한다.
아마 이 단어에 상태라는 표현을 사용하는데 그다지 거부감이 없을 것이다.
그런데 다른 예시를 보면 "이런 것도 상태인가?"하는 의문이 들 것이다.
application state에서는 애플리케이션이 실행되는데 필요한 메모리에 저장된 정보를 말한다.
변수, 쿠키, 힙에 저장된 객체, 현재 페이지 HTML 등을 말하며 저장되어 여러번 재사용되는 데이터가 아니라, 일시적인 정보를 말한다.
resoure state는 이미지, 텍스트, 동영상, 데이터 베이스 정보 등 서버에 자장된 resource를 말한다.
나는 위 내용을 상태라고 번역하는게 그다지 적절해보이진 않는다.
어떤 의미인지 알기 위해 어떤 상황에서 사용되는지 생각해볼 필요가 있다.

일단 state의 사용처를 보면 결국 어떤 정보를 저장하는 것이라는 것을 알 수 있다.
그런데 왜 information, data 같은 단어가 아니라 따로 state를 사용하는 것일까?
내 생각에 가장 큰 차이는 state는 변경된다는 것이다.
언어는 같은 뜻이더라도 뉘앙스에 약간의 차이가 있다.
앞의 data나 information 역시 정보를 의미하지만, 딱히 변하는 내용이라는 뜻은 없다.
반면 state는 현재 정보를 담고 있고, 이것이 명령이나 상황에 따라 변할 수 있다는 느낌이다.
네트워크 state는 통신 상태에 따라 바뀌고, application state도 페이지 구성에 따라 바뀌며, resoure state도 추가, 삭제, 수정 등이 가능하다.
결국 state란 변경가능한 데이터고, 어떤 수단을 통해 state가 변경될 것이라는 유추할 수 있다.
요약하자면 어떤 데이터가 있고, 이를 수정하는 방법이 존재하면 이 데이터를 state라고 표현하는 것이다.

지금까지 알아본 것으로 Representational State가 변경 가능한 데이터인 state를 표현하는 방법인 것을 알게 되었다.
그리고 REST는 Representational State를 전송하는 규칙이란 뜻임을 알았다.
클라이언트-서버 사이에서 요청이 이뤄질 때 필요한 정보(state)가 있을 것이다.
그렇다면 이 state는 어디에 저장되는 것이 좋을까?

1. 클라이언트에 저장한다.
2. 서버에 저장한다.

우리는 유지보수를 위한 원칙을 만드는 것이므로, 위의 선택도 유지보수가 쉬운 선택지를 골라야 한다.
그런 의미에서 서버에 저장하는 것은 나쁜 생각이다.
서버는 동시에 여러 사용자를 상대해야 한다.
이미 해야 할 일이 많은데, 여기다 더해 메모리에 저장해야 할 데이터가 많아지면 감당하기 어렵다.
또한 요청이 이뤄질 때만 잠시 필요한 데이터를 계속 저장하는 것 역시 상당히 큰 낭비다.
그러므로 클라이언트가 이를 보관하고 있다가, 요청시에만 state를 담아 보내는 구조가 좋다.
서버는 요청에 담긴 state를 잠깐 사용하고 그 내용을 버린다.
이로 인해 state를 유지하지 않으므로 이 구조를 *stateless*라고 한다.
간단히 말해 stateless는 받은 state를 저장하지 않는다는 것이다.

stateless로 만들면 몇 가지 특성이 생긴다.
우선 state를 저장하지 않으므로 각 요청을 별개의 것으로 인식한다.
같은 사용자가 요청을 보내더라도 그 사이에 아무런 정보가 유지되지 않기 때문이다.
또한 다음 통신을 위해 준비된 내용이 없으므로 요청에 필요한 데이터가 모두 들어 있어야 한다.
이 말은 곧 요청을 이해하는데 필요한 데이터는 요청에만 들어있고, 다른 데이터는 필요없다는 의미다.
이 특성 덕분에 에러 발생시에 다시 요청을 보내면 간단하게 해결할 수 있는데, 만약 데이터가 여러곳에 나뉘어 있었다면 이를 다시 조합해야 했을 것이다.
그리고 서버 입장에서 요청된 내용만 신경쓰면 되므로, 기능을 확장하기도 좋다.

#### Cacheable

stateless의 도입으로 요청을 독립적으로 만든 것은 좋지만, 문제는 요청이 반복때 낭비가 심하다는 것이다.
그래서 클라이언트측에서 저장할 수 있는 내용은 저장해서 재사용한다는 것이 cacheable이다.
서버는 응답시에 캐시가능한 대상을 지정해서 보내줄 수 있다.

#### Layered System

Layered System은 구조를 층으로 나눠 작성하는 것이다.

그래서 각 층에 필요 없는 다른 계층의 정보를 차단하고 구조가 복잡해지는 것을 막는다.
또한 새로운 기능을 추가할 때 기존의 층은 내버려두고 옆에 새로운 층을 만드는 것으로 해결 가능하다.

#### Code on Demand

마지막으로 Code on demand는 클라이언트가 코드를 다운받고 실행할 수 있게 만들어야 한다는 것으로, 우리는 이미 브라우저에서 자바스크립트를 실행하고 있다.
이 기능을 추가하면 클라이언트에서 일을 처리할 수 있으므로, 서버에서 사전에 모든 코드를 구현할 필요가 없다.
예를 들어 SSR은 서버에서 모든 코드를 구현한 다음 페이지를 전달한다.
그런데 CSR은 클라이언트 측에서 자바스크립트를 실행시켜 페이지를 만들게 한다.
이로 인해 서버의 부하를 줄이고, 클라이언트 측에서 코드로 state 변경이 가능하므로 클라이언트 변경이 용이해진다.
하지만 이 조건은 필수적인 것은 안디ㅏ.

#### Uniform Interface

문제의 Uniform Interface는 아래 4가지를 만족해야 한다.

- identification of resources
- manipulation of resources through representations
- self-descriptive message
- hypermedia as the engine of application state(HATEOAS)

앞의 2개는 자원을 구분하고, 조작할 방법이 필요하단 것이다.
예를 들어 웹은 URL로 자원을 구분하고, HTTP method로 조작한다.
마지막 2개가 문제인데 현대 REST API라 불리는 대부분이 이 둘을 만족하지 못한다.
이에 관한 것은 이후 REST API에서 말해보겠고 지금은 아래 2개가 어떤 의미인지 알아보자.

우선 self-descriptive message는 메세지가 해석하는데 필요한 모든 정보를 담고 있어야 한다는 것이다.
HATEOS는 하이퍼링크로 애플리케이션 상태가 변경되어야 한다는 것이다.
HTML은 이 기능을 모두 만족한다.
HTML은 태그로 해석해서 페이지를 만들 수 있으며, 태그를 해석하기 위해 다른 정보가 필요없다.
그러므로 self-descriptive message를 만족한다.
또한 Link 태그로 하이퍼링크 기능도 쓸 수 있으므로 HATEOS도 만족한다.

그렇다면 아래 2가지 조건이 왜 필요한 것일까?
self-descriptive message는 메세지를 해석하는데 다른 정보가 필요 없음을 말한다고 했다.
이 말은 곧 다른 곳에서 메세지를 쉽게 사용할 수 있음을 의미한다.
다양한 환경에서 메세지를 받아도 필요한 정보가 모두 들어 있으므로 간단하게 표시할 수 있게 된다.
그러므로 self-descriptive는 확장성을 위해 필요하다.

HATEOAS는 링크 수정을 위해 추가되었다.
만약 링크 기능이 없거나 수정 불가능 하면, 그 내용이 고정되어서 수정하기 어려울 것이다.
이 조건 없이는 하이퍼 텍스트를 사용하는 의미가 없으므로 반드시 있어야 한다.

### REST API

REST의 원칙은 API에도 적용되는데, 이를 REST API라고 한다.
REST API의 개념이 퍼지면서 많은 회사에서 REST API를 개발해서 공개하게 된다.
그런데 정작 Roy Fielding은 그들은 REST를 만족하지 못한다고 말하면서 문제가 생긴다.
사람들이 REST API라고 여기는 것이 REST의 원칙을 따르지 않는 것이다.
그렇다면 REST API는 왜 REST를 만족하지 못하는 것일까?

|              | 웹 페이지   | API         |
| ------------ | ----------- | ----------- |
| Protocol     | HTTP        | HTTP        |
| 커뮤니케이션 | 사람 - 기계 | 기계 - 기계 |
| Media Type   | HTML        | JSON, XML   |

위는 웹 페이지와 REST API를 비교한 것이다.
둘을 보면 미디어 타입이 다른 것을 볼 수 있는데, 웹 페이지는 HTML을 사용하고 API는 JSON을 사용한다.
결론부터 말하자면 REST API가 REST를 만족하지 못하는 이유는 Uniform Interface를 만족하지 못하기 때문이다.
정확히 말하자면 self-descriptive와 HATEOAS를 만족하지 못한다.
HTML은 self-descriptive를 만족한다.
각 태그가 브라우저에 주어지면 HTML 명세로 어떤 의미인지 해독할 수 있기 때문이다.
반면 JSON은 해독할 수 없는데, 예를 들어 아래 JSON을 보자.

```
{
  "users": [
    {
      "id": 1,
      "name": "Alice",
    },
    {
      "id": 2,
      "name": "Bob",
    },
  ]
}
```

JSON은 사용자 정보를 담고 있고, id와 name이 들어 있다.
그런데 users, id, name을 브라우저에서 받는다고해서 해석할 수 있을까?
사람 입장에서 보면 id가 고유키를 의미하고, name이 사람 이름을 의미한다는 것을 알 수 있다.
하지만 컴퓨터는 id, name이 무엇인지 알 수 없다.
그래서 저 정보를 받아도 따로 처리해줄 코드를 작성해줘야만 한다.
이는 데이터를 해석하는데 추가적인 정보가 필요한 것이므로, self-descriptive하지 않다.

또한 API는 HATEOAS를 만족하지도 못한다.
HTML은 a태그로 링크를 표시하지만, JSON에는 어디에도 링크 정보가 없다.
그러므로 링크로 데이터를 연결하지 못한다.
둘을 비교한 것을 아래 표에 정리했다.

|                  | HTML      | JSON   |
| ---------------- | --------- | ------ |
| Hyperlink        | a태그     | x      |
| Self-descriptive | HTML 명세 | 불완전 |

결국 사람들은 REST API가 REST를 만족하지 못한다는 사실을 알게 되었다.
이때 선택할 수 있는 가능성은 아래 3가지다.

1. REST API를 실제로 구현해서 REST API라고 한다.
2. REST API를 포기하고 HTTP API라고 한다.
3. REST API는 아니지만 REST API라고 한다.

물론 사람들은 가장 간단한 3번을 선택했다.
그래서 REST API는 REST를 만족하지 못하는 이상한 상태다.
마치 젓가락 행진곡이 사실은 왈츠인것처럼...
하지만 REST 구조는 훌륭하므로 API가 최대한 REST 구조를 만족하도록 하면서 사용하자.

#### 현실에서 REST API

지금까지는 이론적인 부분을 다뤘다면 현실적인 부분을 얘기해보겠다.
우리가 관심 있는 것은 서버에 저장된 데이터를 CRUD로 조작하는 것이다.
이를 웹과 HTTP로 구현해야 하므로, 데이터를 URL로 지정하고 HTTP method로 조작한다.
예를 들어서 사용자에 관한 정보는 /users에 저장한다.
그리고 사용자 각각의 정보는 /users/1, /users/2 처럼 뒤에 숫자로 표시한다.
이들 데이터를 조작하려면 HTTP method를 사용하는데, GET(Read), Post(Create), Put(Update), Delete 명령을 사용한다.
예를 들어 /users/1의 정보를 읽어 오고 싶다면 GET /users/1을 사용하면 되고, 삭제하고 싶다면 DELETE /users/1을 사용하는 식이다.

그런데 URL을 사용할 때 /users/1/get 과 같이 주소에 method를 포함하면 안 된다.
왜냐하면 요청에 이미 method가 포함되기 때문이다.
그러므로 URL에서 받은 method를 확인하고 그에 맞는 코드를 실행시키도록 해야 한다.
어떤 의미인지는 이후 REST API를 직접 만들어보면 이해할 수 있을 것이다.
