---
title: TCP/IP 5 Layer
date: 2022-11-14 10:13:19
category: 카테고리
tag: [Networking, CS]
series: Computer Networking a Top-Down Apporach
excerpt: "What is TCP/IP 5 Layer and introduction of Computer Networking a Top-Down Approach"
cover_image: /images/posts/networking.jpg
draft: true
---

## 왜 네트워크를 배워야 하는가?

처음 프로그래밍을 배울 때 인터넷에서 강의 영상을 많이 따라 했었다.
튜토리얼을 따라 그대로 입력하면 통신이 되었지만, 왜 통신이 되는지 이해할 수 없었다.
그래서 다른 선택지가 어떤 것이 있으며, 각각의 장단점은 무엇이고, 왜 이방법을 선택했는지 설명할 수가 없었다.
나는 이 시점에서 전공 공부를 시작해야 한다고 느꼈다.
다른 사람이 만든 것을 그대로 따라하면 어떻게든 만들 수는 있을 것이다.
그렇지만 대부분은 코드 뒤에 숨겨진 네트워크의 동작 방법은 설명하지 않는다.
원리를 모른채로 사용하면 어떤 점이 문제인지 알 수 없고, 현재 만드는 방법의 옳고 그름을 판단할 수 없다.
프레임워크의 힘을 빌리더라도 기본적인 작동 방법은 이해해야만 제대로 코드를 만들 수 있는 것이다.

이 시리즈는 *Computer Networking a Top-Down Approach*라는 책을 기반으로 정리한 것이다.
처음에는 책의 내용을 그대로 정리하는 것에 그치려고 했으나, 생각보다 부족한 점이 많아서 새로 정리하기로 마음 먹었다.
지금까지 느낀 전공 서적의 가장 큰 문제점은 그 구성이 학습하는데 적절하지 않다는 것이다.
책은 같은 주제를 한 곳에 모아야 하고, 같은 내용을 여러 번 설명하지 않으며, 정직한 방법으로 설명해야 한다.
처음 배우는 사람 뿐만 아니라 복습하는 사람이 원하는 내용을 다시 찾기 쉽도록 만들기 위함일 것이다.
그렇지만 이 때문에 배우기 어려워지기도 한다.
예를 들어 앞의 챕터를 이해하는데 뒷 챕터가 필요하다거나, 연관 지어서 설명하기 좋은 내용을 챕터별로 나누다보니 멀리 떨어지기도 한다.
또한 지나치게 자세할때도 있고, 상대적으로 덜 중요한 내용에 많은 페이지를 할애하기도 한다.
그래서 현실의 강의는 책의 구성을 따라가되 적절히 생략하고 그 순서를 바꾸는 경우가 많은 것이다.
나 역시 책을 그대로 따라가는 것을 비효율적이라 느낀바 새롭게 정리하기로 했다.
내가 중점적으로 생각한 것은 질문의 흐름에 따라 정리하는 것이다.
어떤 내용을 배우면 의문점이 생기고 이를 알아보려 자료를 찾아보는 것이 학습의 흐름이다.
나는 이 물살을 거스르기 보단 그대로 따라가며 설명하려고 한다.
이 과정에서 많은 내용이 중복되리라 생각되지만, 많이 중복되는 내용은 그만큼 중요하다는 의미일 테니 아무리 많이 말해도 부족함이 없을 것이다.
의식의 흐름을 따라가며 적다보니 부족한 점이 많겠지만 여러 번 수정하면서 어떻게든 고쳐나가겠다.

## 네트워크란 무엇인가?

네트워크가 뭔지 물어보면 선뜻 대답하긴 어렵다.
나는 이 질문이 "음악이란 무엇인가?"와 비슷한 질문이라 생각한다.
우리는 일상에서 이미 음악을 많이 들어봤고 생각보다 잘 알고 있다.
만약 아무것도 모르는 사람이라면 음이 틀리거나 박자가 틀려도 아무런 생각 없이 들을 수 있을 것이다.
그렇지만 우리는 이런 실수를 곧잘 알아채곤하고, 누가 잘하고 못하는지 정도는 구분할 수 있다.
네트워크 역시 우리 삶에 녹아들어 대부분의 사람이 사용하고 있는바, 누구나 네트워크가 무엇인지 느낌은 알고 있을 것이다.
이제 중요한 것은 이 감각을 언어로 표현하는 것이다.

내게 네트워크가 무엇인지 물어본다면 나는 *통신 기술을 사용해 의사소통하는 구조*라고 대답할 것이다.
인터넷을 찾아보면 네트워크가 무엇인지 정의하는 방법이 천차만별이다.
이렇게 표현법이 다양한 이유는 네트워크가 무엇인지 짧게 정의하는 것이 불가능하기 때문이다.
잠시 내가 현대 대수학을 배우던 얘기를 해보자.
중고등학교에서 대수는 방정식을 푸는 기술 정도지만, 대학에서는 그 구조를 분석하게 된다.
이 과목은 2학기에 나눠서 배우는 과목이라 1학기에는 기틀을 잡고 2학기에서 본격적인 공부를 하게 된다.
그래서 초심자는 과연 이 과목이 뭘하는 과목인지 감을 잡기 어렵다.
나 역시 무엇을 다루고자 하는 것인지 이해하지 못했기에 주변에 물어봤었는데 대부분은 5차 이상의 방정식에 근의 공식이 없다는 것을 배우는 과목이란 대답이 나왔다.
물론 나는 저 말을 이해하지 못했는데, 1년 수업을 다 수강하면 저 말이 맞다는 것을 인정할 수 밖에 없었다.
이처럼 어떤 과목은 끝까지 공부하기 전엔 개념을 설명하기도 이해하기도 어렵기도 하다.
네트워크 역시 이와 마찬가지로 앞으로 배울 모든 내용이 네트워크가 무엇인지 설명하는 내용이다.
그러므로 네트워크란 말을 간결하게 이해하려면 전체를 이해한 후에나 가능한 것이고, 그 전에는 감각적인 느낌으로만 느끼고 있으면 된다.

## 네트워크의 핵심 개념

지금 당장 네트워크가 무엇인지 정리하는 것은 어렵다고 했지만, 그렇다고 핵심 개념까지 넘길 필요는 없다.
오히려 네트워크의 핵심 개념은 굉장히 간단한 편으로, 앞으로 네트워크를 공부할 때 기억해두는 것이 좋다.
앞서 나는 네트워크를 통신 기술을 사용해 의사소통하는 구조라고 답했다.
현실에서 네트워크 통신 시에 물리적 장치를 사용한다.
랜카드, 라우터, 스위치, 리피터 등 다양한 물리 장치를 사용한다.
하지만 우리는 전자 공학을 공부하는 것이 아니다.
그러므로 물리장치의 구성이나, 세세한 작동 원리를 알 필요가 없다.
몇 가지 개념적인 내용만 정리하면 되는데, 이는 각 장치가 필요할 때마다 설명할 것이다.
결국 물리 장치는 알아서 잘 작동한다고 치고 넘어가면 된다.

### 프로토콜

핵심적인 부분은 의사소통하는 구조라는 것이다.
여기서 우리가 대화하는 것을 생각해보자.
대화는 어느 정도 사회의 암묵적 합의로 이뤄지는 것이다.
한국에서는 한국어로 대화해야 한다는 규칙이 있는데, 만약 중국어로 길을 물어본다면 서로 대화가 통하지 않는다.
마찬가지로 네트워크에서도 통신시에 지켜야할 규칙이 있는데, 이를 *프로토콜*이라고 한다.
아무리 빠르게 데이터를 전송해도 서로 다른 프로토콜을 사용한다면 다른 언어를 사용하는 것이나 다름 없다.
그러므로 데이터를 주고 받을 때 반드시 동일한 프로토콜을 사용해야 한다.

### 데이터 단위(Data Unit)

또 다른 핵심은 데이터를 담아두는 그릇이다.
우리가 대화할 때 말을 사용할 수도 있지만 글자를 사용하기도 한다.
만약 우리가 직접 만나서 대화한다면 말을 사용하는 것이 편할 것이고, 서로 멀리 떨어져 있다면 글로 적어 보내야만 할 것이다.
각 프로토콜 역시 각자에게 적절한 데이터 형태가 정해져 있다.
이를 *데이터 단위*라고 하는데, 각 프로토콜마다 형태와 이름이 다르다.
데이터 단위가 어떻게 구성되는지는 이후에 설명하겠다.
지금은 *각 프로토콜마다 다른 데이터 단위*를 사용한다는 것만 기억하자.

### 계층과 TCP/IP

마지막 핵심은 계층으로 앞의 2개와 달리 설명하기 까다롭다.
왜 계층을 나누고 계층이 서로 어떻게 작동하는지 아는 것이 사실상 네트워크 과목의 목적이나 다름없다.
계층을 이해하려면 최소한 2~3 챕터 정도는 이해할 필요가 있는데, 출발선에서부터 너무 복잡한 설명을 하고 싶지는 않다.
그래서 가볍게 밑그림만 그리고 갈텐데, 현실의 택배 배송을 예시로 들어서 계층이 무엇이며 왜 필요한지 설명해보겠다.

우리가 택배를 보낼 때 일어날 과정을 상상해보자.
택배를 우체국에 들고 가서 목적지를 작성한 다음 맡긴다.
우체국은 목적지에서 가까운 우체국2를 찾고 배송 기사에게 맡긴다.
배송 기사는 최대한 빠르게 갈 수 있는 방법으로 우체국2에 택배를 옮긴다.
마지막으로 우체국2는 택배를 목적지로 전달한다.
이 과정을 순서대로 그리면 아래처럼 된다.

```
+--------------+
|      A       |
|      ↓       |
| Post Office1 |
|      ↓       |
|   Courier    |
|      ↓       |
| Post Office2 |
|      ↓       |
|      B       |
+--------------+
```

여기서 재밌는 사실이 있는데 A는 택배 배송을 맡긴 이후 아무런 일도 하지 않는다는 것이다.
우체국2가 어디가 되어야 하는지, 누가 택배를 배송해야 하는지, 경로는 어떻게 되야할지 아무것도 신경쓰지 않는다.
대신에 A는 그러한 일을 자율적으로 맡기게 된다.
이 때문에 A는 사이 단계에 어떤 일이 발생하는지 알 수 없고 오직 B가 택배를 받는다는 사실만 안다.

```
+--------------+
|      A       |
|      ↓       |
|     ???      |
|      ↓       |
|      B       |
+--------------+
```

우체국 시점도 비슷하게 흘러간다.
우체국은 A가 누구인지 B가 누구인지 전혀 관심이 없다.
다만 목적지만 적절하게 적혀 있으면 된다.
예를 들어서 부산으로 가야하는 택배가 있다면 A가 붙이든, C가 붙이든 아무런 상관이 없다.
마찬가지로 택배원이 누군지, 경로를 어떻게 선택하는지 전혀 관심이 없다.
그 누가 맡더라도 우체국2로 가야한다는 것만 빼면 나머지는 자율적으로 맡기는 것이다.
결국 우체국 입장에서는 배송자나 배송지도 중요하지 않고, 그 아래의 택배원도 중요하지 않다.

```
+--------------+
| Post Office1 |
|      ↓       |
|     ???      |
|      ↓       |
| Post Office2 |
+--------------+
```

마지막으로 택배 기사는 우체국1에서 우체국2로 전달한다는 사실만 알면 된다.
이 일은 단순한 작업으로 택배원이 알아서 목적지로 옮겨준다.

이 예시에서 알 수 있는 것은 대부분은 서로간에 관심이 없다는 것이다.
대부분의 일은 다른 사람에게 일을 위임하기 때문에 알아서 잘 해낼 것이라 믿고 맡긴다.
그리고 이 사이의 일은 신경쓸 필요가 없으므로 사이 과정을 생략하고 상대와 직접 소통한다고 여길 수 있다.
A는 B와 대화하고, 우체국1은 우체국2와 대화한다.
그렇다면 그림으로 표현할 때 A와 B가 대등하고, 우체국1과 우체국2가 대등하므로 아래처럼 그릴 수 있다.

```
+--------------+--------------+
|      A              B       |
+--------------+--------------+
|      ↓              ↑       |
| Post Office1   Post Office2 |
|      ↘              ↗       |
+--------------+--------------+
|            Courier          |
+--------------+--------------+
```

위 그림의 핵심은 서로 대화하는 대상끼리 같은 층에 두었다는 것이다.
이 개념이 바로 계층으로, 계층이란 서로 대화할 수 있는 대등한 대상을 모아둔 것이다.
현대 네트워크는 _TCP/IP_ 구조로 만들어졌고, 5개의 계층으로 나뉘는데 아래와 같다.

```
+-------------+
| Application |
+-------------+
| Transport   |
+-------------+
| Network     |
+-------------+
| Data Link   |
+-------------+
| Physical    |
+-------------+
```

앞서 프로토콜이 통신 규약을 의미하며 의사소통을 위해 정해둔 약속이라 했었다.
계층에서 서로 대화가 가능하다는 것은 곧 같은 프로토콜을 사용한다는 의미다.
그러므로 위 5개의 계층은 각각의 프로토콜을 사용하고, 그에 맞는 데이터 단위를 사용한다.
또한 같은 계층 내에서 서로를 구분하기 위해 주소를 사용하는데, 각자가 사용하는 주소체계가 다르다.
아래는 계층에 맞는 프로토콜, 데이터 단위, 주소 체계를 정리한 것이다.

```
+-------+-------------+--------------------+--------------------+-------------+
| Layer |    Name     |      Protocol      |     Data Unit      | Addressing  |
+-------+-------------+--------------------+--------------------+-------------+
|     5 | Application | HTTP, SMTP, etc... | Messages           | x           |
|     4 | Transport   | TCP/UDP            | Segments/Datagrams | Port        |
|     3 | Network     | IP                 | Packets            | IP Address  |
|     2 | Data Link   | Ethernet, Wi-Fi    | Frames             | MAC Address |
|     1 | Physical    | 10 Base T, 802.11  | Bits               | x           |
+-------+-------------+--------------------+--------------------+-------------+
```

> 컴퓨터 계층을 나누는 방법은 TCP/IP 5계층과 OSI 7계층이 있다.
> 현대 네트워크는 TCP/IP를 사용하지만 개념적 설명을 위해 OSI 7계층을 설명하는 경우도 종종 있다.
> 계층을 나눈 것을 보면 5계층이 7계층에 거의 그대로 포함되는 것을 알 수 있다.
> OSI 7계층이 더 세부적으로 계층을 나눴지만 실제로 구현한 예가 없을 뿐더러, 이미 사회적으로 TCP/IP 계층을 사용하고 있으므로 사람들은 OSI를 사용하지 않는다.
> 그렇지만 애플리케이션을 만들 때 7계층으로 표시하는 방법이 개념적 이해에 도움되는 경우가 있으므로 보조적으로 OSI 7계층을 사용한다.

정리하자면 네트워크는 프로토콜 단위로 계층을 나눈다.
각 계층은 하위 계층에 통신을 위임하고 그 사이에 어떤 일이 발생하는지 모른다.
이는 곧 위임시에 세부적으로 어떻게 동작할지 지정할 수 없다는 의미다.
계층은 프로토콜에 맞는 데이터 단위를 사용하므로, 같은 계층에 전달된 내용을 쉽게 해독할 수 있다.
또한 계층 내에서 서로를 구분하기 위해 주소체계를 사용한다.

### Encapsulation & De-Encapsulation

앞서 계층은 서로 다른 프로토콜을 사용하고, 하위 계층에 통신을 위임한다고 했다.
그런데 통신을 위임할 때, 프로토콜이 달라지므로 데이터 형태도 달라져야 한다.
예를 들어서 Application 계층에서 데이터는 메세지로 만들어진다.
메세지를 상대방에게 전달하려면 하위 계층인 Transport 계층으로 넘겨주는데, Transport 계층은 세그먼트를 사용한다.
그러므로 메세지를 세그먼트로 변경시킬 수 있어야 한다.
나중에 목적지에 도착하면 세그먼트를 다시 메세지로 바꿔줘야 한다.
그렇다면 네트워크는 이를 어떻게 해결할까?

잠시 데이터 단위가 어떻게 만들어지는지 살펴보자.
우리가 "Hello World"라는 본문을 전달하고 싶다면, 이 내용만 전달할 순 없다.
목적지 주소가 필요하고, 언어 정보, 내용 검증용 해시값 등 다양한 것이 필요하다.
이들을 본문 앞에 붙여서 데이터 단위를 만드는데, 이때 앞에 붙는 것을 헤더라고 한다.
이처럼 내용에 헤더를 붙여서 데이터 단위를 만드는 것을 Encapsulation이라고 하며, 반대로 헤더를 떼내어 본문을 복원하는 것을 De-Encapsulation이라 한다.
네트워크는 프로토콜이 바뀌면 Encapsulation을 사용해서 새로운 데이터 형태로 만들어서 문제를 해결한다.
이렇게 하위 계층으로 위임되다보면 여러 헤더가 붙게 되는데, 목적지로 가면서 헤더가 하나씩 벗겨지므로 아무런 문제가 되지 않는다.

## 요약

네트워크는 서로 대화하기 위해 규칙을 정하는데 이를 *프로토콜*이라고 하며, 프로토콜에 따라 *계층*을 나눈다.
각 계층은 정의된 프로토콜에 맞는 데이터 형태가 존재하는데 이를 *데이터 단위*라고 한다.
계층은 통신을 하위 계층에 위임하는데, 이 과정에서 프로토콜과 데이터 단위가 변하게 된다.
그러므로 전달하는 데이터의 형태를 일시적으로 변경시켜야 하는데 이를 *Encapsulation*이라 한다.
Encapsulation은 데이터에 헤더라는 추가 정보를 붙이는 것이고, 역으로 헤더를 제거해 원래 데이터를 복원하는 것을 *De-Encapsulation*라고 부른다.
마지막으로 계층 내에서 서로를 구분하기 위해 *주소*를 사용하며, 이 역시 프로토콜에 따라 다른 이름과 방법을 사용한다.
