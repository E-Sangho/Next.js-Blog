---
title: Instagram2
date: 2022-11-21 10:01:23
category: CloneCoding
tag: [Javascript, React, Python, Django]
series: Create Instagram with React and Django
excerpt: ""
cover_image: /images/posts/networking.jpg
draft: true
---

## Settings before start

터미널을 열어서 `mkdir instagram-clone-backend`로 폴더를 만든다.
그 후 폴더를 열어서 git init으로 깃을 시작한다.

### Poetry installation

[Poetry](https://python-poetry.org/docs/)에서 설치 방법을 찾을 수 있는데, 터미널에 `curl -sSL https://install.python-poetry.org | python3 -`를 입력한다.
설치가 되었는지 확인하기 위해 `poetry`를 입력한다.
명령어가 나오면 제대로 설치된 것이다.
여기서 나는 *zsh: command not found: poetry*라는 오류가 발생했었다.
이는 zsh가 poetry의 위치를 모르기 때문에 발생하는 문제다.
우선 poetry 파일 위치를 알 필요가 있다.
나는 ~/.local/bin에 poetry 파일이 있었다.
위 경로를 ~/.zshrc 파일에 추가해줘야 하는데, 제일 아랫줄에 `export PATH=$HOME/.local/bin:$PATH`를 추가한다.
다시 poetry를 입력하면 poetry가 정상적으로 작동한다.

poetry를 사용하는 이유는 파이썬 가상환경을 만들기 위해서다.
가상환경이 무엇인지 잠시 설명하겠다.
파이썬을 사용하다보면 패키지를 설치해서 사용한다.
그런데 프로젝트마다 패키지를 설치하다보면 서로 다른 버전을 사용해서 문제가 생기기도 한다.
예를 들어서 현재 프로젝트는 django 4.0으로 만들었는데, 이후에 django가 5.0으로 업데이트 되면 작동하지 않는 기능이 생기게 된다.
이처럼 pip를 사용해 패키지를 사용하면 패키지 버전 관리가 어려워진다.
그래서 각 프로젝트마다 개별적인 공간을 만드는데, 이를 가상환경이라고 한다.
가상환경은 패키지를 로컬하게 설치해주므로 각 프로젝트마다 독립적으로 패키지를 사용할 수 있게 된다.
이로 인해 현재 프로젝트에 설치한 패키지가 다른 프로젝트에 영향을 줄 일이 없고, 앞처럼 버전관리로 고생하지 않아도 된다.

`poetry init`으로 poetry 사용을 시작하면 몇 가지 질문이 나온다.
아래처럼 입력하면 된다.

```
>>> poetry init

This command will guide you through creating your pyproject.toml config.

Package name [instagram-clone-backend]:
Version [0.1.0]:
Description []:
Author [Sangho <istrangeho@gmail.com>, n to skip]:
License []:   MIT
Compatible Python versions [^3.9]:

Would you like to define your main dependencies interactively? (yes/no) [yes] no
Would you like to define your development dependencies interactively? (yes/no) [yes] no
Generated file
...
Do you confirm generation? (yes/no) [yes] yes
```

파일을 보면 pyproject.toml이라는 파일이 생성되었다.
그 안에는 우리 프로젝트의 설명이 적혀있고, 사용하는 패키지가 적혀있다.
이제 이 안에 django를 설치해야 하는데 `poetry add django`로 설치할 수 있다.
설치 후에 pyproject.toml 파일을보면 django가 추가되었다.
그리고 poetry.lock 파일이 생성되었는데, 그 안에는 각 패키지의 버전 정보가 적혀있다.
poetry는 install 명령어로 필요한 패키지를 다운받을 수 있는데, 이때 패키지의 최신 버전을 다운 받는다.
그런데 패키지 버전이 달라지면 프로젝트가 작동하지 않을 수 있으므로 poetry.lock 파일에 패키지의 정보를 고정해놓는다.

pyproject.toml과 poetry.lock 파일이 왜 필요한지 좀 더 자세히 설명해보겠다.
프로젝트는 여러 사람이 동시에 진행하므로 같은 버전의 패키지를 사용해야 한다.
pyproject.toml엔 패키지 버전 등이 담겨있지만 패키지간의 의존성은 전혀 설명하지 않는다.
의존성을 적어둘 다른 파일로 poetry.lock를 만든 것이다.
그러므로 깃허브에 배포할 때 pyproject.toml과 poetry.lock 파일을 같이 배포해야만 한다.
만약 poetry.lock 파일을 빼고 배포하면, poetry는 pyproject.toml 파일을 기반으로 새로운 poetry.lock을 만든다.
이때 pyproject.toml에 적힌 프로젝트의 의존성 패키지를 최신 버전으로 설치해서 의존성에 문제가 생긴다.

앞으로 우리가 하는 작업은 poetry 내에서 실행되는 것이다.
그러므로 명령어를 입력하기 전에 `poetry shell`을 입력해야 한다.
그 후 `django-admin`을 입력하면 django-admin의 명령어가 나타난다.
poetry를 종료시키려면 `exit`을 입력하면 된다.

## start project

`poetry shell`, `django-admin startproject config .`으로 현재 위치에 프로젝트를 시작한다.
그러면 config 폴더가 생긴다.

```
config/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py
```

이제 gitignore 파일을 추가해줘야 하는데, vscode의 익스텐션으로 간단하게 해결할 수 있다.
gitignore이라는 익스텐션을 검색해 설치한다.
그 후 설정 > command palette > add gitignore > python으로 gitignore 파일을 만든다.

## run server

`python manage.py runserver`로 서버를 실행해보자.
서버를 실행하면 서버의 url이 출력되고 db.sqlite3라는 파일이 만들어졌다.

```
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).

You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
October 28, 2022 - 00:39:35
Django version 4.1.2, using settings 'config.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```

에러 메세지가 출력되는데 이는 이후 migration에서 배워볼 것이다.

## MVC(Model View Controller)

우리가 만드는 대부분의 애플리케이션은 데이터를 시각적으로 보여주는 일을 한다.
오래전부터 사람들은 저장된 데이터를 사용자에게 보여주는 애플리케이션을 만들어왔고 그 과정에서 공통된 패턴을 발견한다.
이를 MVC 패턴이라고 하며 MVC에 따르면 코드는 데이터를 담당하는 코드, 사용자에게 보이는 부분, 앞의 둘을 조작하는 코드 3가지로 나뉜다.
이들은 각각 Model, View, Controller라고 불린다.

- Model: 데이터 담당
- View: 사용자에게 보이는 시각적 부분 담당
- Controller: Model과 View 사이의 흐름을 담당

왜 이렇게 3개로 나뉘게 되었는지 조금 생각해보자.
데이터를 저장, 삭제, 수정하기 위한 부분인 Model과 사용자에게 보이는 View가 있어야 한다는 것은 쉽게 알 수 있다.
그런데 애플리케이션이 동작하려면 Model에서 데이터를 읽어와 View로 보여줘야 한다.
이렇게 데이터를 읽어와 보여주는 코드는 눈으로 보이는 부분이 아니니 View는 아니다.
또한 이 코드가 저장된 데이터가 아니므로 Model이라고 할 수 없다.
이 코드의 특징은 View와 Model 사이에 존재하며 사용자 명령을 받아 Model을 수정하거나, 반대로 Model의 정보를 읽어와 View에 보여준다는 것이다.
그러므로 View와 Model을 조작한다는 의미에서 Controller라고 이름 붙인게 아닐까 한다.

MVC를 검색해보면 View가 Controller에 의존적이어선 안 된다거나, View는 Model에 의존적일 수 있다는 설명을 보곤한다.
의존적이라는 표현은 모호해서 이해하기 어려운데, 간단히 말해서 코드가 포함되어선 안 된다는 의미다.
각각의 의존관계는 아래와 같다.

- Model: View와 Controller에 의존하지 않는다.
- View: Model에 의존적이고, Controller에는 의존하면 안 된다.
- Controller: Model과 View에 의존적이다.

위가 무슨 의미인지 아래 예를 보고 설명하겠다.

```java
// Model
public class User {
  private String name;
  private String password;
  private String location;

  public User(String name, String password, String location) {
    this.name = name;
    this.password = password;
    this.location = location;
  }

  ...
}

// View
public class View {
  public void showUser(User user) {
    System.out.printIn(
      "User name is " + user.name
    )
  }
}

// Controller
public class Controller {
  public static void main(String[] args) {
    User user = new User("Alice", "abcde", "seoul");
    View.showUser(user);
  }
}
```

위 예시를 보면 Model은 View나 Controller의 내용을 사용하지 않는다.
Model은 순수하게 자기 자신에 관한 일만 다루고 있고, Model과 View의 코드를 포함하지 않는다.
다음으로 View를 보면 Model에 있는 사용자 정보를 가져와서 출력해준다.
View는 Model의 코드를 포함하고 있고, Controller의 코드는 없다.
마지막으로 Controller는 Model과 View의 코드를 둘 다 사용하고 있다.
이 관계를 그림으로 표현하면 아래처럼 된다.

```
    Model
  ↙       ↘
View  →   Controller
```

위 그림은 코드의 포함 관계만을 나타낸 것으로 흐름과는 관계 없다.
Model이 View에서 사용되긴 하지만, 코드상 직접적으로 가져와서 사용하진 않는다.
대신에 Controller에서 양쪽을 불러와서 일을 처리한다.
MVC가 동작하는 순서는 아래처럼 표시할 수 있다.

```
╔═════════════╗            ╔════════════════ Web Server ═════════════╗
║             ║            ║                                         ║
║             ║            ║                          //============ 3 ==========\\
║             ║            ║ +------------+           || +-------+   ║   +----+  ||
║             ║            ║ |            | --- 2 --> || | Model | <---> | DB |  ||
║             ║  --- 1 --> ║ |            | <-- 4 --- || +-------+   ║   +----+  ||
║ Web Browser ║            ║ |            |           \\=============║===========//
║             ║            ║ | Controller |                          ║
║             ║  <-- 7 --- ║ |            |            +------+      ║
║             ║            ║ |            | --- 5 -->  | View |      ║
║             ║            ║ |            | <-- 6 ---  |      |      ║
║             ║            ║ +------------+            +------+      ║
║             ║            ║                                         ║
╚═════════════╝            ╚═════════════════════════════════════════╝
```

1. 웹 브라우저에서 서버에 요청을 보내고, 서버는 요청에 맞는 컨트롤러를 선택한다.
2. 컨트롤러는 모델을 호출한다.
3. 모델은 객체를 생성하거나, DB에서 불러온다.
4. 결과값을 컨트롤러에 돌려준다.
5. 모델로부터 받은 값을 View에게 전달한다.
6. View는 값을 바탕으로 출력 결과를 만들어서 컨트롤러에게 돌려준다.
7. 서버는 웹 브라우저에게 요청값을 전달하고, 브라우저는 이를 화면에 표시한다.

## MTV(Model Template View)

django는 MVC 패턴 대신 MTV 패턴을 사용한다.
둘은 큰 틀에서 닮았는데 View를 Template으로 Controller는 View로 대체하면 비슷한 역할을 한다.
하지만 둘이 정확히 같은 구조는 아니다.
예를 들어서 도서관 백엔드를 만든다고 하자.
MVC 구조는 Controller가 데이터베이스에서 책 정보를 불러오고 View에게 건낸다.
View에서 보여줄 정보를 만든 다음 Controller에게 돌려준다.
Controller는 이를 URL과 결합시켜서 사용자에게 돌려준다.

django는 위처럼 데이터를 불러오거나, URL과 결합시키는 코드를 작성하지 않는다.
위 일들은 django 프레임워크가 대신하며, 단지 적절한 위치에 해야할 일을 적어주면 알아서 처리해준다.
좀 더 간단히 표현하자면 Controller에서 처리해야 할 일을 django가 맡고 있는 것이다.
django의 View와 Template는 MVC 패턴의 View를 나눈 것이라 생각할 수 있다.
MVC는 View에서 어떤 정보가 어떻게 보일지를 정했었다.
django는 이를 둘로 나눠서 어떤 정보가 보일지를 View에, 어떻게 보일지를 Template에 적도록 나눈 것이다.
요약하자면 django는 MVC 패턴에서 Controller가 할 일을 프레임워크가 대신하고 있다.
그리고 View의 일을 2개로 나눠서 View와 Template에 따로 작성하도록 만들었다.

왜 django가 MTV 패턴을 사용하는걸까?
이는 코드 작성이 더 쉽고, 수정하기 용이해서다.
django는 Controller가 해야 할 일을 대신해준다.
덕분에 해당 코드를 작성할 필요도 없고, View와 Model의 연결 관계가 좀 더 느슨해진다.
그래서 View에 코드를 쓰기 편하고, 또 변경 사항이 생겨도 어렵지 않게 수정할 수 있다.

## App 만들기

`python manage.py startapp polls`

```
polls/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
```

### View

```python
# polls/views.py
from django.http import HttpResponse

def index(request):
    return HttpResponse("This is polls")
```

View를 호출하려면 연결된 URL이 필요한데, URLconf로 이어준다.
urls.py라는 파일을 생성하고 아래처럼 작성한다.

```python
# polls/urls/py
from django.urls import path

from . import views

urlpatterns = [
  path("", views.index, name="index"),
]
```

다음으로 config 폴더의 urls.py를 열고 아래처럼 include 시킨다.

```python
# config/urls.py
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
  path("polls/", include("polls.urls")),
  path("admin/", admin.site.urls),
]
```

include는 다른 URLconf를 참조할 수 있도록한다.
django는 include를 만나면 URL에서 지금까지 일치하는 점은 잘라내고, 남은 문자열을 URLconf로 전달한다.

서버를 실행하고 페이지에 들어가면 View에서 작성한 내용이 보인다.

path는 route, view를 인수로 사용한다.
route에는 URL 패턴을 적고, 일치하는 패턴을 찾으면 view에 전달한다.

###

config/settings.py 파일엔 django 설정을 위한 변수가 저장되어 있다.
django는 기본적으로 SQLite를 사용하도록 만들어져 있다.
