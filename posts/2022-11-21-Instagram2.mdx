---
title: Instagram2
date: 2022-11-21 10:01:23
category: CloneCoding
tag: [Javascript, React, Python, Django]
series: Create Instagram with React and Django
excerpt: ""
cover_image: /images/posts/networking.jpg
draft: true
---

## Settings before start

터미널을 열어서 `mkdir instagram-clone-backend`로 폴더를 만든다.
그 후 폴더를 열어서 git init으로 깃을 시작한다.

### Poetry installation

[Poetry](https://python-poetry.org/docs/)에서 설치 방법을 찾을 수 있는데, 터미널에 `curl -sSL https://install.python-poetry.org | python3 -`를 입력한다.
설치가 되었는지 확인하기 위해 `poetry`를 입력한다.
명령어가 나오면 제대로 설치된 것이다.
여기서 나는 *zsh: command not found: poetry*라는 오류가 발생했었다.
이는 zsh가 poetry의 위치를 모르기 때문에 발생하는 문제다.
우선 poetry 파일 위치를 알 필요가 있다.
나는 ~/.local/bin에 poetry 파일이 있었다.
위 경로를 ~/.zshrc 파일에 추가해줘야 하는데, 제일 아랫줄에 `export PATH=$HOME/.local/bin:$PATH`를 추가한다.
다시 poetry를 입력하면 poetry가 정상적으로 작동한다.

poetry를 사용하는 이유는 파이썬 가상환경을 만들기 위해서다.
가상환경이 무엇인지 잠시 설명하겠다.
파이썬을 사용하다보면 패키지를 설치해서 사용한다.
그런데 프로젝트마다 패키지를 설치하다보면 서로 다른 버전을 사용해서 문제가 생기기도 한다.
예를 들어서 현재 프로젝트는 django 4.0으로 만들었는데, 이후에 django가 5.0으로 업데이트 되면 작동하지 않는 기능이 생기게 된다.
이처럼 pip를 사용해 패키지를 사용하면 패키지 버전 관리가 어려워진다.
그래서 각 프로젝트마다 개별적인 공간을 만드는데, 이를 가상환경이라고 한다.
가상환경은 패키지를 로컬하게 설치해주므로 각 프로젝트마다 독립적으로 패키지를 사용할 수 있게 된다.
이로 인해 현재 프로젝트에 설치한 패키지가 다른 프로젝트에 영향을 줄 일이 없고, 앞처럼 버전관리로 고생하지 않아도 된다.

`poetry init`으로 poetry 사용을 시작하면 몇 가지 질문이 나온다.
아래처럼 입력하면 된다.

```
>>> poetry init

This command will guide you through creating your pyproject.toml config.

Package name [instagram-clone-backend]:
Version [0.1.0]:
Description []:
Author [Sangho <istrangeho@gmail.com>, n to skip]:
License []:   MIT
Compatible Python versions [^3.9]:

Would you like to define your main dependencies interactively? (yes/no) [yes] no
Would you like to define your development dependencies interactively? (yes/no) [yes] no
Generated file
...
Do you confirm generation? (yes/no) [yes] yes
```

파일을 보면 pyproject.toml이라는 파일이 생성되었다.
그 안에는 우리 프로젝트의 설명이 적혀있고, 사용하는 패키지가 적혀있다.
이제 이 안에 django를 설치해야 하는데 `poetry add django`로 설치할 수 있다.
설치 후에 pyproject.toml 파일을보면 django가 추가되었다.
그리고 poetry.lock 파일이 생성되었는데, 그 안에는 각 패키지의 버전 정보가 적혀있다.
poetry는 install 명령어로 필요한 패키지를 다운받을 수 있는데, 이때 패키지의 최신 버전을 다운 받는다.
그런데 패키지 버전이 달라지면 프로젝트가 작동하지 않을 수 있으므로 poetry.lock 파일에 패키지의 정보를 고정해놓는다.

pyproject.toml과 poetry.lock 파일이 왜 필요한지 좀 더 자세히 설명해보겠다.
프로젝트는 여러 사람이 동시에 진행하므로 같은 버전의 패키지를 사용해야 한다.
pyproject.toml엔 패키지 버전 등이 담겨있지만 패키지간의 의존성은 전혀 설명하지 않는다.
의존성을 적어둘 다른 파일로 poetry.lock를 만든 것이다.
그러므로 깃허브에 배포할 때 pyproject.toml과 poetry.lock 파일을 같이 배포해야만 한다.
만약 poetry.lock 파일을 빼고 배포하면, poetry는 pyproject.toml 파일을 기반으로 새로운 poetry.lock을 만든다.
이때 pyproject.toml에 적힌 프로젝트의 의존성 패키지를 최신 버전으로 설치해서 의존성에 문제가 생긴다.

앞으로 우리가 하는 작업은 poetry 내에서 실행되는 것이다.
그러므로 명령어를 입력하기 전에 `poetry shell`을 입력해야 한다.
그 후 `django-admin`을 입력하면 django-admin의 명령어가 나타난다.
poetry를 종료시키려면 `exit`을 입력하면 된다.

## start project

`poetry shell`, `django-admin startproject config .`으로 현재 위치에 프로젝트를 시작한다.
그러면 config 폴더가 생긴다.

```
config/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py
```

이제 gitignore 파일을 추가해줘야 하는데, vscode의 익스텐션으로 간단하게 해결할 수 있다.
gitignore이라는 익스텐션을 검색해 설치한다.
그 후 설정 > command palette > add gitignore > python으로 gitignore 파일을 만든다.

## run server

`python manage.py runserver`로 서버를 실행해보자.
서버를 실행하면 서버의 url이 출력되고 db.sqlite3라는 파일이 만들어졌다.

```
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).

You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
October 28, 2022 - 00:39:35
Django version 4.1.2, using settings 'config.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```

에러 메세지가 출력되는데 이는 이후 migration에서 배워볼 것이다.

## MVC(Model View Controller)

우리가 만드는 대부분의 애플리케이션은 데이터를 시각적으로 보여주는 일을 한다.
오래전부터 사람들은 저장된 데이터를 사용자에게 보여주는 애플리케이션을 만들어왔고 그 과정에서 공통된 패턴을 발견한다.
이를 MVC 패턴이라고 하며 MVC에 따르면 코드는 데이터를 담당하는 코드, 사용자에게 보이는 부분, 앞의 둘을 조작하는 코드 3가지로 나뉜다.
이들은 각각 Model, View, Controller라고 불린다.

- Model: 데이터 담당
- View: 사용자에게 보이는 시각적 부분 담당
- Controller: Model과 View 사이의 흐름을 담당

왜 이렇게 3개로 나뉘게 되었는지 조금 생각해보자.
데이터를 저장, 삭제, 수정하기 위한 부분인 Model과 사용자에게 보이는 View가 있어야 한다는 것은 쉽게 알 수 있다.
그런데 애플리케이션이 동작하려면 Model에서 데이터를 읽어와 View로 보여줘야 한다.
이렇게 데이터를 읽어와 보여주는 코드는 눈으로 보이는 부분이 아니니 View는 아니다.
또한 이 코드가 저장된 데이터가 아니므로 Model이라고 할 수 없다.
이 코드의 특징은 View와 Model 사이에 존재하며 사용자 명령을 받아 Model을 수정하거나, 반대로 Model의 정보를 읽어와 View에 보여준다는 것이다.
그러므로 View와 Model을 조작한다는 의미에서 Controller라고 이름 붙인게 아닐까 한다.

MVC를 검색해보면 View가 Controller에 의존적이어선 안 된다거나, View는 Model에 의존적일 수 있다는 설명을 보곤한다.
의존적이라는 표현은 모호해서 이해하기 어려운데, 간단히 말해서 코드가 포함되어선 안 된다는 의미다.
각각의 의존관계는 아래와 같다.

- Model: View와 Controller에 의존하지 않는다.
- View: Model에 의존적이고, Controller에는 의존하면 안 된다.
- Controller: Model과 View에 의존적이다.

위가 무슨 의미인지 아래 예를 보고 설명하겠다.

```java
// Model
public class User {
  private String name;
  private String password;
  private String location;

  public User(String name, String password, String location) {
    this.name = name;
    this.password = password;
    this.location = location;
  }

  ...
}

// View
public class View {
  public void showUser(User user) {
    System.out.printIn(
      "User name is " + user.name
    )
  }
}

// Controller
public class Controller {
  public static void main(String[] args) {
    User user = new User("Alice", "abcde", "seoul");
    View.showUser(user);
  }
}
```

위 예시를 보면 Model은 View나 Controller의 내용을 사용하지 않는다.
Model은 순수하게 자기 자신에 관한 일만 다루고 있고, Model과 View의 코드를 포함하지 않는다.
다음으로 View를 보면 Model에 있는 사용자 정보를 가져와서 출력해준다.
View는 Model의 코드를 포함하고 있고, Controller의 코드는 없다.
마지막으로 Controller는 Model과 View의 코드를 둘 다 사용하고 있다.
이 관계를 그림으로 표현하면 아래처럼 된다.

```
    Model
  ↙       ↘
View  →   Controller
```

위 그림은 코드의 포함 관계만을 나타낸 것으로 흐름과는 관계 없다.
Model이 View에서 사용되긴 하지만, 코드상 직접적으로 가져와서 사용하진 않는다.
대신에 Controller에서 양쪽을 불러와서 일을 처리한다.
MVC가 동작하는 순서는 아래처럼 표시할 수 있다.

```
╔═════════════╗            ╔════════════════ Web Server ═════════════╗
║             ║            ║                                         ║
║             ║            ║                          //============ 3 ==========\\
║             ║            ║ +------------+           || +-------+   ║   +----+  ||
║             ║            ║ |            | --- 2 --> || | Model | <---> | DB |  ||
║             ║  --- 1 --> ║ |            | <-- 4 --- || +-------+   ║   +----+  ||
║ Web Browser ║            ║ |            |           \\=============║===========//
║             ║            ║ | Controller |                          ║
║             ║  <-- 7 --- ║ |            |            +------+      ║
║             ║            ║ |            | --- 5 -->  | View |      ║
║             ║            ║ |            | <-- 6 ---  |      |      ║
║             ║            ║ +------------+            +------+      ║
║             ║            ║                                         ║
╚═════════════╝            ╚═════════════════════════════════════════╝
```

1. 웹 브라우저에서 서버에 요청을 보내고, 서버는 요청에 맞는 컨트롤러를 선택한다.
2. 컨트롤러는 모델을 호출한다.
3. 모델은 객체를 생성하거나, DB에서 불러온다.
4. 결과값을 컨트롤러에 돌려준다.
5. 모델로부터 받은 값을 View에게 전달한다.
6. View는 값을 바탕으로 출력 결과를 만들어서 컨트롤러에게 돌려준다.
7. 서버는 웹 브라우저에게 요청값을 전달하고, 브라우저는 이를 화면에 표시한다.

## MTV(Model Template View)

django는 MVC 패턴 대신 MTV 패턴을 사용한다.
둘은 큰 틀에서 닮았는데 View를 Template으로 Controller는 View로 대체하면 비슷한 역할을 한다.
하지만 둘이 정확히 같은 구조는 아니다.
예를 들어서 도서관 백엔드를 만든다고 하자.
MVC 구조는 Controller가 데이터베이스에서 책 정보를 불러오고 View에게 건낸다.
View에서 보여줄 정보를 만든 다음 Controller에게 돌려준다.
Controller는 이를 URL과 결합시켜서 사용자에게 돌려준다.

django는 위처럼 데이터를 불러오거나, URL과 결합시키는 코드를 작성하지 않는다.
위 일들은 django 프레임워크가 대신하며, 단지 적절한 위치에 해야할 일을 적어주면 알아서 처리해준다.
좀 더 간단히 표현하자면 Controller에서 처리해야 할 일을 django가 맡고 있는 것이다.
django의 View와 Template는 MVC 패턴의 View를 나눈 것이라 생각할 수 있다.
MVC는 View에서 어떤 정보가 어떻게 보일지를 정했었다.
django는 이를 둘로 나눠서 어떤 정보가 보일지를 View에, 어떻게 보일지를 Template에 적도록 나눈 것이다.
요약하자면 django는 MVC 패턴에서 Controller가 할 일을 프레임워크가 대신하고 있다.
그리고 View의 일을 2개로 나눠서 View와 Template에 따로 작성하도록 만들었다.

왜 django가 MTV 패턴을 사용하는걸까?
이는 코드 작성이 더 쉽고, 수정하기 용이해서다.
django는 Controller가 해야 할 일을 대신해준다.
덕분에 해당 코드를 작성할 필요도 없고, View와 Model의 연결 관계가 좀 더 느슨해진다.
그래서 View에 코드를 쓰기 편하고, 또 변경 사항이 생겨도 어렵지 않게 수정할 수 있다.

## App 만들기

`python manage.py startapp polls`

```
polls/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
```

### View

```python
# polls/views.py
from django.http import HttpResponse

def index(request):
    return HttpResponse("This is polls")
```

View를 호출하려면 연결된 URL이 필요한데, URLconf로 이어준다.
urls.py라는 파일을 생성하고 아래처럼 작성한다.

```python
# polls/urls/py
from django.urls import path

from . import views

urlpatterns = [
  path("", views.index, name="index"),
]
```

다음으로 config 폴더의 urls.py를 열고 아래처럼 include 시킨다.

```python
# config/urls.py
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
  path("polls/", include("polls.urls")),
  path("admin/", admin.site.urls),
]
```

include는 다른 URLconf를 참조할 수 있도록한다.
django는 include를 만나면 URL에서 지금까지 일치하는 점은 잘라내고, 남은 문자열을 URLconf로 전달한다.

서버를 실행하고 페이지에 들어가면 View에서 작성한 내용이 보인다.

path는 route, view를 인수로 사용한다.
route에는 URL 패턴을 적고, 일치하는 패턴을 찾으면 view에 전달한다.

url에 변수를 포함하려면 <type:var>형태로 입력하면 된다.
예를 들어서 id를 정수값으로 사용하고 싶으면 <int:id>로 적어서 아래처럼 사용한다.

```python
# polls/urls.py
from django.urls import path

from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('<int:id>/', views.detail, name='detail'),

]
```

여기서 url에 적힌 변수는 view 파일에서 아래처럼 변수로 받아서 사용한다.

```python
# polls/views.py
def detail(request, id):
    return HttpResponse("You're looking at question %s." % id)
```

### Databases

config/settings.py 파일엔 django 설정을 위한 변수가 저장되어 있다.
django는 기본적으로 SQLite를 사용하도록 만들어져 있다.
다른 데이터베이스를 사용하고 싶다면 [DATABASES](https://docs.djangoproject.com/ko/4.1/ref/databases/#third-party-notes) 페이지를 보고 바꾸면 된다.

INSTALLED_APPS에 활성화된 모든 애플리케이션이 적혀있다.
처음에는 admin, auth, session 등의 기본적인 애플리케이션만 적혀있다.
이 중에는 데이터베이스 테이블을 사용하는 경우가 있어서, 테이블을 만들어줘야 정상적으로 작동한다.
`python manage.py migrate`
migrate 명령은 INSTALLED_APPS에 적힌 앱들의 데이터베이스 테이블을 생성한다.

앱을 INSTALLED_APPS에 추가하려면 아래처럼 적어준다.

```python
# config/settings.py
INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```

### Model

django에서 모델을 만들려면 django.db.models.Model을 상속받아서 만들어야 한다.
각 모델은 models.py 안에 만들어주며 어떤 필드를 포함할지는 django.db.models 안에서 가져와서 사용한다.

```python
# polls/models.py
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
```

필드 이름(question_text, pub_date 등)은 필드 이름으로 사용되며, 나중에 데이터베이스를 확인해보면 column으로 사용된다.
몇몇 필드는 인수를 반드시 필요로 하는데, 예를 들어 CharField는 max_length를 꼭 적어줘야 한다.
그 외에 default 같은 선택적인 변수가 있는데, 필요한 경우 django의 문서를 참고하자.

ForeignKey 필드를 사용해 다른 모델을 가져올 수도 있다.
이때 ForeignKey로 가져온 모델이 삭제될경우 어떻게 해야할지 on_delete에 적어줘야 한다.

모델을 만들었으면 django에게 모델을 변경시킨 사실과, 이를 migration으로 저장하고 싶다는 것을 알려야 한다.
우선은 config/settings.py의 INSTALLED_APPS에 앱을 등록해야 한다.
그 다음 `python manage.py makemigrations polls`로 django에게 이를 알린다.

django가 모델을 migration으로 저장하는데, 깃허브처럼 매번 버전을 migrations 폴더에 만들어둔다.
migraion에 어떤 내용이 있는지 보려면 `python manage.py sqlmigrate polls 0001` 명령을 입력한다.

```sql
BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" bigint NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
```

마이그레이션을 바탕으로 데이터베이스에 모델 테이블을 만들려면 `python manage.py migrate`를 실행한다.
migrate는 마이그레이션을 실행하며, 모델의 변경 사항과 데이테베이스의 스키마의 동기화가 이뤄진다.

- models.py에서 모델을 변경
- python manage.py makemigrations 로 마이그레이션 제작
- python manage.py migrate 로 데이터베이스에 적용

### Template

django를 DB관리와 API 용으로 사용하고, 프론트는 React로 만들 생각이라면 이 항목은 읽지 않아도 된다.
Template는 django에서 HTML로 페이지를 만들게 해준다.
이때 정적인 부분만 Template로 만들고 동적인 부분은 View에서 만들어 기능과 디자인을 구분해야 편하게 만들 수 있다.
polls 폴더에 templates 폴더를 만들고 polls.html 파일에 아래처럼 적어준다.

```python
# polls/templates/polls.html
{% if latest_question_list %}
    <ul>
    {% for question in latest_question_list %}
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}
```

위 코드를 보면 짐작하겠지만 HTML과 파이썬 코드를 혼용하고 있다.
이때 파이썬 코드는 {%%} 안에 적어줘야 하는데, 일반적인 파이썬 코드와 달리 {% endfor %}처럼 for문이 종료되는 위치를 적어줘야 한다.
간단하게 말해 HTML의 태그가 열리고 닫히듯이 파이썬 코드를 사용해야 한다는 의미다.

이제 위에서 만든 파일을 View에서 보여주려고 한다.
loader를 사용하는 방법과 render를 사용하는 방법이 있는데 각각의 장단점이 있다.

#### loader

django.template.loader를 사용해서 페이지를 불러올 수 있다.
이때 사용하는 변수는 context 내에 적어준다음 render에 전달해줘야 한다.

```python
# polls/views.py
from django.http import HttpResponse
from django.template import loader

from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    template = loader.get_template('polls.html')
    context = {
        'latest_question_list': latest_question_list,
    }
    return HttpResponse(template.render(context, request))
```

#### render

그런데 위처럼 Template를 사용하는 방법은 꽤나 자주 사용되므로, 좀 더 간결하게 render만으로 페이지를 만들 수 있게 되어있다.
loader과 HttpResponse를 사용하지 않고 아래처럼 적어줘도 같은 페이지가 나온다.

```python
# polls/views.py
from django.shortcuts import render

from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_question_list': latest_question_list}
    return render(request, 'polls/index.html', context)
```

보다시피 render이 훨씬 간결하고 보기 좋다.
그럼에도 HttpResponse의 속성을 사용해야할 경우엔 HttpResponse를 사용해야 한다.

보다시피 Template를 사용한 방법은 완전히 HTML로 만들어야 한다.
이는 물론 정적인 페이지나 간단한 결과를 보여주고 싶을 때, 사용하기 좋다.
그렇지만 대부분은 Template를 사용하지 않는다.
대신 React로 프론트 작업을 한다음 API로 django와 연결하는 방법을 많이 사용한다.

### Admin

django는 기본적으로 관리자 페이지가 존재한다.

#### superuser

`python manage.py createsuperuser`

username, email, password를 입력해 계정을 만든다.

`python manage.py runserver`로 서버 실행

http://localhost:8000/admin/ 에서 로그인

admin 페이지에 poll app이 없음

admin에서 수정하려면 polls/admin.py에 모델을 추가해줘야 함

```python
# polls/admin.py
from django.contrib import admin

from .models import Question

admin.site.register(Question)
```

## REST Framework

웹 공부를 하면서 REST API라는 말을 종종 들었다.
그동안은 대충 정해진 URL에 HTTP 메소드를 사용해 소통하는 방법 정도로 이해하고 있었다.
REST가 무엇인지 잘 이해하지 못하다보니, 제대로 REST를 따르고 있는지 알 수 없어서 이번 기회에 제대로 정리해봤다.
추천하는 영상으로 [그런 REST API로 괜찮은가?](https://www.youtube.com/watch?v=RP_f5dMoHFc)를 보기를 권한다.
설명이 굉장히 깔끔하고 이해하기 쉽게 구성되어 있다.

### API

나는 친구들과 종종 카페에 가는 편인데, 단 음료를 좋아해서 카라멜 마끼아또를 시키곤 한다.
그 후 자리를 잡고 친구들과 얘기를 나누다가 음료가 나오면 거기에 빨대를 꽂아 마신다.
아마 이 글을 보자마자 각자가 카페에서 음료를 마시는 모습이 떠올랐을 것이다.
이때 뒤에서 바리스타가 커피를 어떻게 만드는지 관심을 가져본적이 있는가?
나는 별로 그런적이 없는 것 같다.
사람은 이처럼 어떻게 그 음료가 만들어졌는지 크게 관심을 가지지 않는다.
왜냐하면 직접 재료를 준비하고 만드는 과정이 번거롭기도하고, 만드는 모습에 별 관심이 없기 때문이다.
사람들은 그저 음료에 빨대를 꽂아 맛있게 먹는 것만 신경쓴다.
내가 이런 예기를 한 이유는 API가 빨대와 다름 없기 때문이다.
빨대는 남이 만들어둔 맛있는 음료를 별다른 고생 없이 먹기 위한 도구다.
마찬가지로 API는 누군가 고생해가며 만든 기능의 달콤한 결과물만 가져온다.
이게 무슨 의민지는 차차 설명하기로 하고 지금은 API는 빨대라는 것만 기억하자.

API는 Application Programming Interface의 약자다.
여기서 Interface가 무엇인지 살펴보자.
한국 사람이 아랍 사람과 만난다면 당연하게 의사소통이 안 된다.
둘이 대화하려면 어쩔 수 없이 통역사를 고용해야만 한다.
Interface는 이처럼 둘 사이에서 소통이 가능하도록 만들어주는 장치를 말한다.
예를 들어 사람이 컴퓨터에게 명령하기 위해선 키보드와 마우스가 필요한데, 키보드와 마우스가 대표적인 인터페이스다.
여기서 인터페이스는 하드웨어 장치 뿐만 아니라 소프트웨어적 개념도 포함한다.
소프트웨어 사이의 인터페이스는 여러 종류가 있지만, 그 중에서도 대표적인 예가 애플리케이션 사이의 인터페이스 다시 말해 API다.

API가 애플리케이션 사이에 소통할 수 있게 해주는 코드라는 사실은 알았다.
그런데 구체적으로 API가 왜 필요하며 어떤 일을 해주길래 소통하게 해준다는 것일까?
각 지역별 날씨를 알려주는 애플리케이션을 만들고 싶다고 하자.
그러면 우리는 각 지역마다 날씨 측정용 장비를 설치하고, 그 내용을 전송할 회선을 만들고, 측정값을 저장할 서버를 만들고, 또 이 내용을 가져와서 코드를 작성하는 등 해야할 일이 끝없이 늘어나게 된다.
단지 우리는 날씨를 알고 싶을 뿐인데 투자해야하는 돈과 시간이 무지막지해서 도저히 불가능하다.
그런데 이미 우리나라엔 기상청이라는 날씨를 측정하는 기관이 있다.
얌체같지만 복잡한 일은 모두 기상청에게 떠넘기고, 그 결과만을 편하게 쓸 수 있다면 좋을 것이다.
다시 말해 기상청이 만들어 놓은 꿀 같은 정보를 빨대로 빨아먹고 싶은 것이다.
우리가 기상청의 데이터를 가져오려면 기상청이 날씨 정보를 가져갈 수 있는 인프라를 만들어야 가능하고, 이 인프라가 바로 기상청 날씨 API다.
이로 인해 복잡한 일은 기상청에서 하고 우리는 API를 통해서 그 결과만을 받아오는 것이다.
정리하자면 API는 프로그래머가 직접하기 힘든 일을 처리할 때 사용된다.
해당 일을 위임하기도 하고 저장된 내용을 가져오기도 하는데, 그 사이에서 코드로 간결하게 호출할 수 있도록 만든 것이 API다.

API와 라이브러리가 비교되곤 하는데 둘은 다른 개념이다.
라이브러리는 재사용할 코드를 묶음으로 만들어 다음에도 쓰기 쉽게 만든 것이고, API는 다른 대상과 소통하기 위한 기능이다.
비유적으로 표현하자면 라이브러리는 상품이고 API는 통신 기술이다.
우리 주변엔 많은 상품이 있는데, 예를 들어 전화기, 축구공, 자동차 등이 있다.
이들은 공장에서 만들어서 일괄적으로 동일한 서비스를 제공하고 A 축구공과 B 축구공은 다른 점이 없다.
이중 휴대폰, 컴퓨터 같은 몇몇 상품은 통신 기술이 들어 있어서 다른 사람과 소통하는데 쓸 수 있다.
그런데 상품과 통신 기술은 전혀 다른 것이다.
일부 상품에 통신 기술이 들어 있긴 하지만 포함관계도 아닌 것이다.
API는 두 애플리케이션 사이에서 소통하게 해주는 코드다.
라이브러리는 여러 코드를 묶은 것으로 그 안에서 API를 호출하는 경우도 있지만, 아닌 경우도 있다.

### REST

인터넷이 생겨남으로써 사람들은 어떻게 인터넷으로 정보를 공유할지 고민하게 되었다.
그 결과물로 이메일, 토렌트, 게임 등이 인터넷을 사용하지만, 그 중에서 가장 큰 성공을 거둔 것은 웹이다.
그렇다면 웹은 어떻게 그렇게 큰 성공을 거둘 수 있었을까?
정보를 보여줄 때 중요한 것은 어떤 것을 보여줄 것인가 뿐만 아니라, 정보를 어떻게 연결할지다.
웹은 각 정보를 링크로 연결해준다.
덕분에 모르는 내용이 생기거나 다른 내용을 읽고 싶으면 링크를 클릭하는 것만으로 간단하게 해당 정보를 볼 수 있다.
이는 굉장한 점인데, 예를 들어 책은 중간에 모르는 단어가 생겨도 해당 내용을 찾을 수 없고, 이메일 또한 내용이 적혀 있기만 할 뿐 다른 이메일과 연결되지 않는다.
웹에선 이 링크를 하이퍼 텍스트라고 하는데, 기존의 앞뒤로 이어지는 텍스트가 아니라 서로를 건너다닐 수 있는 텍스트라는 의미다.

웹이 하이퍼 텍스트를 사용한다는 사실을 알았지만 아직 남은 문제가 있다.
어떻게 하이퍼 텍스트를 표시할지, 정보를 어떻게 식별할지, 그리고 어떻게 전송할지다.
하이퍼 텍스트를 표시하기 위해 HTML(Hyper Text Markup Language)을 사용한다.
여기서 HT가 하이퍼 텍스트인것은 알겠는데, 뒤의 Markup Language는 무엇일까?
마크업 언어는 태그를 사용해 구조를 표시하는 언어다.
다시 말해 색, 크기, 간격, 모양 등의 구조를 앞뒤로 태그를 사용해 표시하는 언어다.
그렇기 때문에 HTML이 앞뒤로 태그를 사용하는 것이다.

다음으로 각 정보를 어떻게 식별할지다.
책은 각 페이지마다 정해진 정보가 적혀있다.
마찬가지로 웹에서도 같은 페이지를 찾을 방법이 필요했고 이를 URI(Uniform Resource Identifier)라고 한다.
URI는 그 이름에서 볼 수 있듯이 각 정보마다 id를 줘서 대상을 일정하게 찾을 수 있게 고안되었다.
우리 일상에서 가장 쉽게 볼 수 있는 URI는 URL로, 프로토콜, 호스트, 경로, 쿼리를 사용해서 각 리소스를 구분한다.
전송 방법은 HTTP 프로토콜을 사용한다.

정리하자면 웹은 아래의 3가지로 구성된다.

- 표현형식: HTML
- 식별자: URI
- 전송 방법: HTTP

그러던중 Roy Fielding이란 사람이 HTTP 작업에 참여하게 되면서 고민이 생겼다.
HTTP를 고치면 기존에 사용하던 웹과 호환성 문제가 발생하는데, 어떻게 웹은 망가뜨리지 않고 만들 수 있을지에 관한 것이었다.
즉, 유지보수시에 문제가 생기지 않을 구조를 고민한 것이다.
이 생각은 이후에 정리되어 박사 논문으로 발표되는데 이것이 바로 REST다.

REST(Representational State Transfer)는 네트워크 통신시 지켜야할 규칙을 정리한 것이다.
물론 웹 역시 네트워크의 일부이므로, 웹에도 적용되는 사항이다.
REST의 원칙은 API에도 적용되는데, 이를 REST API라고 한다.
REST API의 개념이 퍼지면서 많은 회사에서 REST API를 개발해서 공개하게 된다.
그런데 정작 Roy Fielding은 그들은 REST를 만족하지 못한다고 말하면서 문제가 생긴다.
사람들이 REST API라고 여기는 것이 REST의 원칙을 따르지 않는 것이다.
그렇다면 REST API는 왜 REST를 만족하지 못하는 것일까?
이를 알기 위해 REST가 무엇인지 알아보자.
아래는 REST의 원칙이다.

- Client/Server
- Stateless
- Cacheable
- Layered System
- Uniform Interface
- Code on demand(optional)

여기서 문제가 되는 것은 Uniform Interface인데, 일단은 나머지를 간단히 설명하겠다.
앞서 말했듯 REST는 유지보수를 위한 원칙이다.
클라이언트와 서버로 나누면 연관된 코드만 다루니 기능 변경이 쉬울 것이다.
stateless인 것은 같은 사용자의 요청이더라도 각 요청을 다른 사람이 요청한 것처럼 받아들인단 것이다.
이는 서버에서 요청하는 사람의 정보를 저장하지 않는다는 의미고, 또한 각 요청은 서버가 이해하는데 필요한 모든 정보를 포함하고 있어야 한다.
하지만 같은 내용을 여러번 보내는 것은 낭비이므로, 클라이언트측에서 저장할 수 있는 내용은 저장해서 재사용한다는 것이 cacheable이다.
Layered System은 구조를 층으로 나눠 작성하는 것으로, 각 층의 기능을 너무 복잡하지 않게 만들게 해준다.
마지막으로 Code on demand는 클라이언트가 코드를 다운받고 실행할 수 있게 만들어야 한다는 것으로, 우리는 이미 브라우저에서 자바스크립트를 실행하고 있다.

문제의 Uniform Interface는 아래 4가지를 만족해야 한다.

- identification of resources
- manipulation of resources through representations
- self-descriptive message
- hypermedia as the engine of application state(HATEOAS)

첫 번째는 자원에 주소를 지정해야 한다는 것인데, 이미 URI를 사용해서 잘 지정하고 있다.
두 번째는 자원을 조작할 표현이 있어야 한다는 것으로, HTTP의 method로 컨트롤 가능하다.
마지막 2개가 문제인데 현대 REST API라 불리는 대부분이 이 둘을 만족하지 못한다.

우선 self-descriptive message는 메세지가 해석하는데 필요한 모든 정보를 담고 있어야 한다는 것이다.
그런데 REST API로 전송되는 정보는
HATEOS는 하이퍼링크로 애플리케이션 상태가 변경되어야 한다는 것이다.
웹사이트는 링크로 페이지를 이동하므로 이를 잘 따른다.

웹은 대부분 REST가 잘 지쳐짐(서버가 변경되거나 프론크라 변경되어도 문제 없음), 반면 앱은 잘 안 됨(서버가 변경되면 앱을 업데이트 해야 작동함)

### REST API

REST는 성공적이지만 REST API는 REST 조건을 다 만족하진 못한다.

1. REST API를 실제로 구현해서 REST API라고 한다.
2. REST API를 포기하고 HTTP API라고 한다.
3. REST API는 아니지만 REST API라고 한다.

3번 선택

API는 왜 REST가 잘 안되나? 웹 페이지는 잘 되었는데...

|              | 웹 페이지   | API         |
| ------------ | ----------- | ----------- |
| Protocol     | HTTP        | HTTP        |
| 커뮤니케이션 | 사람 - 기계 | 기계 - 기계 |
| Media Type   | HTML        | JSON        |

미디어 타입이 다름

|                  | HTML      | JSON   |
| ---------------- | --------- | ------ |
| Hyperlink        | a태그     | x      |
| Self-descriptive | HTML 명세 | 불완전 |

HTML 명세에 각 태그가 무슨 의미인지 적혀 있음.
반면 JSON은 key-value의 의미를 알 수가 없다.

Self-descriptive: 확장 가능성
HATEOAS: 링크를 마음대로 수정가능

- Client-Server - 클라이언트와 서버로 분리되어야하며 서로 의존성이 없어야 한다.
- Stateless(무상태성) - 상태 정보를 따로 저장하지 않으며, 이용자가 누구인지 혹은 어디서 접근하는지와 관계 없이 결과가 무조건 동일해야 한다. 따라서 REST API는 필연적으로 오픈될 수밖에 없다.
- Cache - HTTP를 비롯한 네트워크 프로토콜에서 제공하는 캐싱 기능을 적용할 수 있어야 한다.
- Uniform Interface - 데이터가 표준 형식으로 전송될 수 있도록 구성 요소 간 통합 인터페이스를 사용한다. REST API 태반이 HTTP를 사용하기 때문에 HTTP 표준인 URL과 응답 코드, Request-Response Method 등을 사용한다.
- Layered System - API는 REST 조건을 만족하면 필연적으로 오픈될 수 밖에 없기 때문에, 요청된 정보를 검색하는데 있어 계층 구조로 분리되어야 한다.
- Self-descriptiveness - API를 통해 전송되는 내용은 별도 문서 없이 쉽게 이해할 수 있도록 자체 표현 구조를 지녀야 한다. 마찬가지로 웹 표준인 JSON과 XML이 절찬리에 사용중이다.
