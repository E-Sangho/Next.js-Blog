---
title: Instagram2
date: 2022-11-21 10:01:23
category: CloneCoding
tag: [Javascript, React, Python, Django]
series: Create Instagram with React and Django
excerpt: ""
cover_image: /images/posts/networking.jpg
draft: true
---

## Settings before start

터미널을 열어서 `mkdir instagram-clone-backend`로 폴더를 만든다.
그 후 폴더를 열어서 git init으로 깃을 시작한다.

### Poetry installation

[Poetry](https://python-poetry.org/docs/)에서 설치 방법을 찾을 수 있는데, 터미널에 `curl -sSL https://install.python-poetry.org | python3 -`를 입력한다.
설치가 되었는지 확인하기 위해 `poetry`를 입력한다.
명령어가 나오면 제대로 설치된 것이다.
여기서 나는 *zsh: command not found: poetry*라는 오류가 발생했었다.
이는 zsh가 poetry의 위치를 모르기 때문에 발생하는 문제다.
우선 poetry 파일 위치를 알 필요가 있다.
나는 ~/.local/bin에 poetry 파일이 있었다.
위 경로를 ~/.zshrc 파일에 추가해줘야 하는데, 제일 아랫줄에 `export PATH=$HOME/.local/bin:$PATH`를 추가한다.
다시 poetry를 입력하면 poetry가 정상적으로 작동한다.

poetry를 사용하는 이유는 파이썬 가상환경을 만들기 위해서다.
가상환경이 무엇인지 잠시 설명하겠다.
파이썬을 사용하다보면 패키지를 설치해서 사용한다.
그런데 프로젝트마다 패키지를 설치하다보면 서로 다른 버전을 사용해서 문제가 생기기도 한다.
예를 들어서 현재 프로젝트는 django 4.0으로 만들었는데, 이후에 django가 5.0으로 업데이트 되면 작동하지 않는 기능이 생기게 된다.
이처럼 pip를 사용해 패키지를 사용하면 패키지 버전 관리가 어려워진다.
그래서 각 프로젝트마다 개별적인 공간을 만드는데, 이를 가상환경이라고 한다.
가상환경은 패키지를 로컬하게 설치해주므로 각 프로젝트마다 독립적으로 패키지를 사용할 수 있게 된다.
이로 인해 현재 프로젝트에 설치한 패키지가 다른 프로젝트에 영향을 줄 일이 없고, 앞처럼 버전관리로 고생하지 않아도 된다.

`poetry init`으로 poetry 사용을 시작하면 몇 가지 질문이 나온다.
아래처럼 입력하면 된다.

```
>>> poetry init

This command will guide you through creating your pyproject.toml config.

Package name [instagram-clone-backend]:
Version [0.1.0]:
Description []:
Author [Sangho <istrangeho@gmail.com>, n to skip]:
License []:   MIT
Compatible Python versions [^3.9]:

Would you like to define your main dependencies interactively? (yes/no) [yes] no
Would you like to define your development dependencies interactively? (yes/no) [yes] no
Generated file
...
Do you confirm generation? (yes/no) [yes] yes
```

파일을 보면 pyproject.toml이라는 파일이 생성되었다.
그 안에는 우리 프로젝트의 설명이 적혀있고, 사용하는 패키지가 적혀있다.
이제 이 안에 django를 설치해야 하는데 `poetry add django`로 설치할 수 있다.
설치 후에 pyproject.toml 파일을보면 django가 추가되었다.
그리고 poetry.lock 파일이 생성되었는데, 그 안에는 각 패키지의 버전 정보가 적혀있다.
poetry는 install 명령어로 필요한 패키지를 다운받을 수 있는데, 이때 패키지의 최신 버전을 다운 받는다.
그런데 패키지 버전이 달라지면 프로젝트가 작동하지 않을 수 있으므로 poetry.lock 파일에 패키지의 정보를 고정해놓는다.

pyproject.toml과 poetry.lock 파일이 왜 필요한지 좀 더 자세히 설명해보겠다.
프로젝트는 여러 사람이 동시에 진행하므로 같은 버전의 패키지를 사용해야 한다.
pyproject.toml엔 패키지 버전 등이 담겨있지만 패키지간의 의존성은 전혀 설명하지 않는다.
의존성을 적어둘 다른 파일로 poetry.lock를 만든 것이다.
그러므로 깃허브에 배포할 때 pyproject.toml과 poetry.lock 파일을 같이 배포해야만 한다.
만약 poetry.lock 파일을 빼고 배포하면, poetry는 pyproject.toml 파일을 기반으로 새로운 poetry.lock을 만든다.
이때 pyproject.toml에 적힌 프로젝트의 의존성 패키지를 최신 버전으로 설치해서 의존성에 문제가 생긴다.

앞으로 우리가 하는 작업은 poetry 내에서 실행되는 것이다.
그러므로 명령어를 입력하기 전에 `poetry shell`을 입력해야 한다.
그 후 `django-admin`을 입력하면 django-admin의 명령어가 나타난다.
poetry를 종료시키려면 `exit`을 입력하면 된다.

## start project

`poetry shell`, `django-admin startproject config .`으로 현재 위치에 프로젝트를 시작한다.
그러면 config 폴더가 생긴다.
현재까지 폴더 내용은 아래처럼 되어야 한다.

```
config/
    __init__.py
    asgi.py
    settings.py
    urls.py
    wsgi.py
manage.py
poetry.lock
pyproject.toml
```

각 파일이 어떤 경우에 사용되는지는 이후에 차차 배울 것이다.
이제 gitignore 파일을 추가해줘야 하는데, vscode의 익스텐션으로 간단하게 해결할 수 있다.
gitignore이라는 익스텐션을 검색해 설치한다.
그 후 설정 > command palette > add gitignore > python으로 gitignore 파일을 만든다.

### Databases

config/settings.py 파일엔 django 설정을 위한 변수가 저장되어 있다.
django는 기본적으로 SQLite를 사용하도록 만들어져 있다.
다른 데이터베이스를 사용하고 싶다면 [DATABASES](https://docs.djangoproject.com/ko/4.1/ref/databases/#third-party-notes) 페이지를 보고 바꾸면 된다.

## Settings for Convenience

### Pylance

코드를 작성하다보면 자동완성 기능을 사용해서 오타를 줄이는 것이 큰 도움이 된다.
그런데 django에서 여러 함수나 메서드를 사용할 때 변수가 적절히 자동완성되지 않는 단점이 있다.
그래서 Pylance를 사용하기로 했다.
vscode는 Pylance라는 확장 프로그램을 사용해서 타입을 체크하고 변수를 자동 완성할 수 있다.
vscode의 extensions에서 pylance를 검색해서 설치해준다.
그런데 몇몇 파일을 보면 노란줄로 경고를 해주고 있다.
이는 우리가 django를 global하게 설치하지 않고 poetry를 사용하기 때문에 발생한다.
파일을 찾으려고 해도 파이썬 인터프리터에서 django를 찾지 못해서 경고해주는 것이다.
그러므로 vscode에서 poetry를 인터프리터로 사용하도록 만들어야 한다.
cmd + shit + p를 눌러서 명령어 검색창을 띄운다.
그리고 python select interpreter를 찾아준다.
이제 인터프리터 경로를 지정해야 하는데 poetry를 선택하면 된다.
여기서 poetry 경로가 안 나올 경우 터미널에서 poetry env info --path로 경로를 검색해서 복사한다.
그리고 인터프리터 선택 창에서 제일 위를 보면 인터프리터 경로를 추가하는 버튼이 있는데, 이를 눌러서 앞의 경로를 붙여넣기 한다.
이렇게하면 poetry를 선택할 수 있게 된다.

### Black Formatter

자바스크립트를 사용할 때 prettier라는 코드를 정리해주는 확장자를 사용했다.
파이썬에도 코드를 규칙에 맞게 정리해주는 확장자가 존재하는데, Black Formatter를 설치해주면 된다.
vscode의 확장자에서 black formatter를 검색하고 설치해준다.
이제 파이썬 코드를 작성하고 저장하면 규칙에 맞게 적절하게 코드를 바꿔주는데, 일관성이 있어서 읽기도 편하고 별도로 신경쓸 필요가 없어서 편한다.

## run server

앞서 프로젝틀를 시작하며 만든 파일 중에서 manage.py 파일이 있었다.
manage.py는 django에서 필요한 온갖 기능을 적어둔 파일로, 우리는 대부분의 기능을 이 파일을 실행해서 구현한다.
예를 들어 서버를 시작하거나, 애플리케이션을 만들거나, 변경 내용을 적용하는 등의 대부분의 기능이 이 파일에 만들어져 있다.
다른 기능은 이후에 소개하기로 하고 일단은 서버를 실행하려면 `python manage.py runserver`를 입력한다.
그러면 \_pycache\_라는 폴더와 db.sqlite3 파일이 생성된다.
콘솔을 보면 서버를 "http://127.0.0.1:8000/"에 실행시키고 있다.

```
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).

You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
December 05, 2022 - 06:25:21
Django version 4.1.3, using settings 'config.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```

메세지를 보면 18개의 마이그레이션이 적용되지 않았다는 에러가 보일 것이다.
이는 이후에 배울 것이고 일단은 넘어간다.

## MVC(Model View Controller)

우리가 만드는 대부분의 애플리케이션은 데이터를 시각적으로 보여주는 일을 한다.
오래전부터 사람들은 저장된 데이터를 사용자에게 보여주는 애플리케이션을 만들어왔고 그 과정에서 공통된 패턴을 발견한다.
이를 MVC 패턴이라고 하며 MVC에 따르면 코드는 데이터를 담당하는 코드, 사용자에게 보이는 부분, 앞의 둘을 조작하는 코드 3가지로 나뉜다.
이들은 각각 Model, View, Controller라고 불린다.

- Model: 데이터 담당
- View: 사용자에게 보이는 시각적 부분 담당
- Controller: Model과 View 사이의 흐름을 담당

왜 이렇게 3개로 나뉘게 되었는지 조금 생각해보자.
데이터를 저장, 삭제, 수정하기 위한 부분인 Model과 사용자에게 보이는 View가 있어야 한다는 것은 쉽게 알 수 있다.
그런데 애플리케이션이 동작하려면 Model에서 데이터를 읽어와 View로 보여줘야 한다.
이렇게 데이터를 읽어와 보여주는 코드는 눈으로 보이는 부분이 아니니 View는 아니다.
또한 이 코드가 저장된 데이터가 아니므로 Model이라고 할 수 없다.
이 코드의 특징은 View와 Model 사이에 존재하며 사용자 명령을 받아 Model을 수정하거나, 반대로 Model의 정보를 읽어와 View에 보여준다는 것이다.
그러므로 View와 Model을 조작한다는 의미에서 Controller라고 이름 붙인게 아닐까 한다.

MVC를 검색해보면 View가 Controller에 의존적이어선 안 된다거나, View는 Model에 의존적일 수 있다는 설명을 보곤한다.
의존적이라는 표현은 모호해서 이해하기 어려운데, 간단히 말해서 코드가 포함되어선 안 된다는 의미다.
각각의 의존관계는 아래와 같다.

- Model: View와 Controller에 의존하지 않는다.
- View: Model에 의존적이고, Controller에는 의존하면 안 된다.
- Controller: Model과 View에 의존적이다.

위가 무슨 의미인지 아래 예를 보고 설명하겠다.

```java
// Model
public class User {
  private String name;
  private String password;
  private String location;

  public User(String name, String password, String location) {
    this.name = name;
    this.password = password;
    this.location = location;
  }

  ...
}

// View
public class View {
  public void showUser(User user) {
    System.out.printIn(
      "User name is " + user.name
    )
  }
}

// Controller
public class Controller {
  public static void main(String[] args) {
    User user = new User("Alice", "abcde", "seoul");
    View.showUser(user);
  }
}
```

위 예시를 보면 Model은 View나 Controller의 내용을 사용하지 않는다.
Model은 순수하게 자기 자신에 관한 일만 다루고 있고, Model과 View의 코드를 포함하지 않는다.
다음으로 View를 보면 Model에 있는 사용자 정보를 가져와서 출력해준다.
View는 Model의 코드를 포함하고 있고, Controller의 코드는 없다.
마지막으로 Controller는 Model과 View의 코드를 둘 다 사용하고 있다.
이 관계를 그림으로 표현하면 아래처럼 된다.

```
    Model
  ↙       ↘
View  →   Controller
```

위 그림은 코드의 포함 관계만을 나타낸 것으로 흐름과는 관계 없다.
Model이 View에서 사용되긴 하지만, 코드상 직접적으로 가져와서 사용하진 않는다.
대신에 Controller에서 양쪽을 불러와서 일을 처리한다.
MVC가 동작하는 순서는 아래처럼 표시할 수 있다.

```
╔═════════════╗            ╔════════════════ Web Server ═════════════╗
║             ║            ║                                         ║
║             ║            ║                          //============ 3 ==========\\
║             ║            ║ +------------+           || +-------+   ║   +----+  ||
║             ║            ║ |            | --- 2 --> || | Model | <---> | DB |  ||
║             ║  --- 1 --> ║ |            | <-- 4 --- || +-------+   ║   +----+  ||
║ Web Browser ║            ║ |            |           \\=============║===========//
║             ║            ║ | Controller |                          ║
║             ║  <-- 7 --- ║ |            |            +------+      ║
║             ║            ║ |            | --- 5 -->  | View |      ║
║             ║            ║ |            | <-- 6 ---  |      |      ║
║             ║            ║ +------------+            +------+      ║
║             ║            ║                                         ║
╚═════════════╝            ╚═════════════════════════════════════════╝
```

1. 웹 브라우저에서 서버에 요청을 보내고, 서버는 요청에 맞는 컨트롤러를 선택한다.
2. 컨트롤러는 모델을 호출한다.
3. 모델은 객체를 생성하거나, DB에서 불러온다.
4. 결과값을 컨트롤러에 돌려준다.
5. 모델로부터 받은 값을 View에게 전달한다.
6. View는 값을 바탕으로 출력 결과를 만들어서 컨트롤러에게 돌려준다.
7. 서버는 웹 브라우저에게 요청값을 전달하고, 브라우저는 이를 화면에 표시한다.

## MTV(Model Template View)

django는 MVC 패턴 대신 MTV 패턴을 사용한다.
둘은 큰 틀에서 닮았는데 View를 Template으로 Controller는 View로 대체하면 비슷한 역할을 한다.
하지만 둘이 정확히 같은 구조는 아니다.
예를 들어서 도서관 백엔드를 만든다고 하자.
MVC 구조는 Controller가 데이터베이스에서 책 정보를 불러오고 View에게 건낸다.
View에서 보여줄 정보를 만든 다음 Controller에게 돌려준다.
Controller는 이를 URL과 결합시켜서 사용자에게 돌려준다.

django는 위처럼 데이터를 불러오거나, URL과 결합시키는 코드를 작성하지 않는다.
위 일들은 django 프레임워크가 대신하며, 단지 적절한 위치에 해야할 일을 적어주면 알아서 처리해준다.
좀 더 간단히 표현하자면 Controller에서 처리해야 할 일을 django가 맡고 있는 것이다.
django의 View와 Template는 MVC 패턴의 View를 나눈 것이라 생각할 수 있다.
MVC는 View에서 어떤 정보가 어떻게 보일지를 정했었다.
django는 이를 둘로 나눠서 어떤 정보가 보일지를 View에, 어떻게 보일지를 Template에 적도록 나눈 것이다.
요약하자면 django는 MVC 패턴에서 Controller가 할 일을 프레임워크가 대신하고 있다.
그리고 View의 일을 2개로 나눠서 View와 Template에 따로 작성하도록 만들었다.

왜 django가 MTV 패턴을 사용하는걸까?
이는 코드 작성이 더 쉽고, 수정하기 용이해서다.
django는 Controller가 해야 할 일을 대신해준다.
덕분에 해당 코드를 작성할 필요도 없고, View와 Model의 연결 관계가 좀 더 느슨해진다.
그래서 View에 코드를 쓰기 편하고, 또 변경 사항이 생겨도 어렵지 않게 수정할 수 있다.

## App

앞으로 우리는 MVT 패턴에 맞춰 여러 코드를 작성할 것이다.
이때 서로 연관된 코드는 한 폴더에 정리하는 것이 좋다.
예를 들어 사용자와 관련된 MVT는 모두 users 폴더에 작성해야 유지보수가 편하다.
그외에도 댓글, 포스트 등 다양한 폴더를 만들게 될텐데, 결국 코드는 폴더 단위로 나뉘게 된다.
django는 이렇게 나뉘는 폴더 단위를 *앱*이라고 부른다.
각 앱에는 모델, 뷰, 컨트롤러, url 등의 내용이 들어가며, 이후에 어떻게 사용하는지 배울 것이다.
처음에는 앱이 좀 복잡해 보일지도 모르지만, 결국 앱이란 코드를 폴더 단위로 나눈 것에 불과하다.
용어가 익숙하지 않다면 처음에는 그냥 폴더라고 이해하고 지나쳐도 된다.

앱을 만들기 위해선 `python manage.py startapp users`로 테스트용 앱을 만든다.
폴더를 보면 아래처럼 구성된다.

```
users/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
```

### Model

#### Create Model

django에서 모델을 만들려면 django.db.models.Model을 상속받아서 만들어야 한다.
각 모델은 models.py 안에 만들어주며 어떤 필드를 포함할지는 django.db.models 안에서 가져와서 사용한다.
아래는 사용자 모델을 만든 것이다.

```python
# users/models.py
from django.db import models

# Create your models here.

class User(models.Model):

  """ User definition for models"""

  name = models.CharField(max_length=30)
  email = models.CharField(max_length=50)
  description = models.TextField()
  join_date = models.DateTimeField("date published")

```

User 모델은 models.Model을 상속 받아 만들어진다.
이때 주석으로 어떤 내용인지 적어두는 것이 이후에 큰 도움이 된다.
모델은 필드 이름(name, email, join_date 등)을 적어줘야 하는데, 이는 엑셀의 column처럼 사용된다.
그리고 각 필드에 어떤 데이터 타입이 들어갈지 지정해줘야 한다.
몇몇 필드는 인수를 반드시 필요로 하는데, 예를 들어 CharField는 max_length를 꼭 적어줘야 한다.
그 외에 default 같은 선택적인 변수가 있는데, 필요한 경우 django의 문서를 참고하자.

#### Migrations

모델을 만들었으면 django에게 모델을 변경시킨 사실과, 이를 migration으로 저장하고 싶다는 것을 알려야 한다.
config/settings.py 파일을 열어보면 INSTALLED_APPS가 있는데, 이 위치에 모델을 등록한다.

```python
# config/settings.py

INSTALLED_APPS = [
    ...
    'users.apps.UsersConfig',
]
```

그 다음 `python manage.py makemigrations users`로 django에게 이를 알린다.
그러면 아래처럼 메세지가 나온다.

```
Migrations for 'users':
  users/migrations/0001_initial.py
    - Create model User
```

폴더를 보면 migrations 폴더에 0001_initial.py라는 파일이 생긴 것을 볼 수 있다.

```python
# houses/migrations/0001_initial.py
 class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='House',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=140)),
                ('price', models.PositiveBigIntegerField()),
                ('description', models.TextField()),
                ('address', models.CharField(max_length=140)),
            ],
        ),
    ]
```

일단 makemigraions 명령어를 입력하면 마이그레이션이 생긴다는 사실은 알았는데 마이그레이션이 무엇일까?
DB는 sql이라는 언어를 사용하는데, 데이터를 추가, 삭제, 수정을 하려면 sql문을 작성해서 실행해야 한다.
앞서 우리는 사용자 모델을 만들었는데, name에는 string을 입력하도록 설정했다.
이 내용을 sql로도 구현해서 적용해줘야만 하는 것이다.
즉, 지금까지 우리가 작성한 모델은 서버에서 사용하기 위한 코드고, 이에 맞춰 DB에서 사용할 sql 코드가 필요한 것이다.
그런데 우리는 이미 모델을 만들었고 어떤 내용이 들어가야할지 지정해줬다.
이 내용이 sql과 거의 똑같기 때문에 만약 모델을 자동으로 sql로 번역할 수 있다면, 번거롭게 sql을 작성할 필요가 없을 것이다.
django는 이런 기능을 기본적으로 지원하므로 우리가 간편하게 사용할 수 있다.

django는 모델을 보고 데이터베이스가 어떻게 바뀌어야 할지 알아서 만들어준다.
이를 migraion이라 하며, `python manage.py makemigrations 앱이름`으로 실행할 수 있다.
마이그레이션은 깃허브처럼 매번 버전을 만들어 migrations 폴더에 저장한다.
이를 바탕으로 모델의 변화를 추적하고 데이터베이스를 적절히 수정할 수 있다.
예를 들어서 사용자 모델의 name 필드를 id로 이름을 바꿨다고 해보자.
만약 현재 상태만을 가지고 마이그레이션을 만든다면 필드명이 바뀐 것을 알 수 없을 것이고, 그에 맞춰 sql을 작성할 수 없게 된다.
그러므로 현재 모델과 이전 마이그레이션을 같이 고려해서 sql을 작성해야 하고, 각 마이그레이션 버전을 만드는 것이다.
앞서 사용자 모델로 마이그레이션을 만들었다면 0001_initial.py 파일이 있을 것이다.
이 파일의 내용을 확인해보려면 `python manage.py sqlmigrate users 0001`을 입력하면 된다.

```sql
BEGIN;
--
-- Create model User
--
CREATE TABLE "users_user" (
  "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
  "name" varchar(30) NOT NULL,
  "email" varchar(50) NOT NULL,
  "description" text NOT NULL,
  "join_date" datetime NOT NULL
);
COMMIT;
```

마이그레이션은 데이터베이스에 사용할 명령을 만드는 작업이다.
이를 실제로 적용하려면 `python manage.py migrate`를 실행해야 한다.

```
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions, users
Running migrations:
  Applying users.0001_initial... OK
```

이제 admin 페이지에 들어가서 모델을 확인해보면 정상적으로 보이는 것을 알 수 있다.
지금까지 마이그레이션 관련 내용을 요약하면 아래와 같다.

- models.py에서 모델을 변경
- python manage.py makemigrations 로 마이그레이션 제작
- python manage.py migrate 로 데이터베이스에 적용

#### Foreign key

User 모델은 하위 항목에 사진이나, houses 모델, 메세지 등 다양한 것을 포함해야 한다.
이때 각 모델은 따로 만들어질텐데 어떻게 포함되게 만들까?
가장 간단한 방법은 User 모델에 모든 내용을 붙여넣는 것이다.
하지만 이 방법은 중복된 데이터가 너무 많이 발생하는데다가, 하나의 모델이 수정되면 연결된 내용을 모두 찾아서 수정해줘야 하는 번거로움이 있다.
그래서 데이터베이스는 PK(Primary Key)를 사용한다.
각 모델은 고유의 Pk를 가지고 있고, 다른 모델과 연결될 필요가 있으면 Pk만 사용하면 간결하게 연결할 수 있는 것이다.
예를 들어 house 모델에 소유자를 추가해서 User 모델을 연결하려고 한다고 하자.
그러면 아래의 owner 필드에 내용을 채워줘야 한다.

| description  | address | pets_allowed | owner |
| ------------ | ------- | ------------ | ----- |
| home sharing | Seoul   | True         |       |

만약 여기서 모든 내용을 복사해서 넣어주려면 owner 항목 뿐만 아니라 user 모델의 모든 필드가 추가되어야 한다.
하지만 ID를 사용하면 간단하게 user의 Pk를 추가하면 된다.

| description  | address | pets_allowed | owner |
| ------------ | ------- | ------------ | ----- |
| home sharing | Seoul   | True         | 1     |

Pk는 유일하기 때문에 user 모델의 내용을 바로 찾을 수 있다.
그러므로 소유자에 Pk를 적은 것만으로도 모든 데이터를 복사한 것과 같은 효과를 누릴 수 있다.
이처럼 모델간의 연결은 Pk를 사용한다.
이때 Pk는 별도로 설정할 필요가 없는데, django에서 알아서 Pk를 추가해주기 때문이다.

이제 houses에 owner를 추가하는 방법을 알아보겠다.
owner 필드를 만들고 models.ForeignKey()를 사용하면 된다.
ForeignKey는 대상 모델과 on_delete라는 패러매터를 사용한다.

```python
class House(models.Model):
  ...
  owner = models.ForeignKey(
    "users.User",
    on_delete=models.CASCADE,
  )

```

여기서 "users.User"는 연결되는 모델의 구조를 알아야 하므로 왜 필요한지 납득이 된다.
그렇다면 on_delete는 왜 필요한 것일까?
모델은 만든 뒤에도 여러 번 수정이 필요하다.
이때 해당 모델이 필요 없다고 생각된다면 지우게 된다.
그렇다면 User 모델이 지워지면 houses 모델은 어떻게 되어야 할까?
첫 번째는 해당 모델을 남기는 경우다.
예를 들어서 결제 내역을 생각해보자.
결제 내역엔 어떤 사용자가 결제했는지 알아야 하므로 ForeignKey로 연결해줄 필요가 있다.
이때 사용자가 탈퇴를 하더라도 결제 내역은 그대로 유지해야 한다.
그러므로 사용자 항목을 NULL로 바꿔주고 모델을 그대로 남겨야 한다.
이 경우 사용하는 것이 *on_delete=models.SET_NULL*이다.
위와 같이 설정하면 연결된 모델이 삭제되더라도 해당 값을 NULL로 설정하고 그대로 남겨준다.
두 번째는 모델을 같이 삭제하는 경우다.
이는 *on_delete=models.CASCADE*로 적어주면 된다.

지금까지 모델을 수정하고 연결하는 방법을 알아봤다.
여기서 owner 필드를 추가했기 때문에 새로 migration을 해야하는데, 이전의 데이터 때문에 default 값을 지정해줘야 한다.
만약 프로젝트가 이미 많은 데이터를 가지고 있다면 어쩔 수 없이 default를 만들어서 바꿔줘야겠지만, 우리는 아직 별다른 작업을 하지 않았으므로 migration과 db 파일을 지우고 새로 시작하는 것이 빠르다.
우선 각 migrations 폴더에 000#\_###.py 형태의 migraions를 삭제해준다.
다음으로 db.sqlite3를 삭제하고 `python manage.py makemigraions`와 `pyhton manage.py migrate`를 차례로 입력해준다.
`pyhton manage.py createsuperuser`로 새로운 관리자 계정을 만들어준다.

#### Following relationships backward

지금까지 ForeignKey를 사용해서 모델을 연결하는 방법을 알아봤다.
ForeignKey를 사용하면 room에 owner 필드를 추가할 수 있고, 이로 인해 각 room의 소유자를 알 수 있었다.
그런데 반대로 가지고 있는 room을 모두 알아내려면 어떻게 해야 할까?
조금 더 정리해서 설명하자면 우리는 room -> owner의 관계를 만들었다.
그래서 각 방의 주인을 찾을 수 있었고, 모델을 따라가서 원하는 정보를 불러올 수 있었다.
이제 반대로 주인에게 어떤 방이 연결되어 있는지 알아보려고 한다.
그런데 우리는 room에 owner 필드를 추가했지만, user 모델에 room을 추가하지 않았다.
물론 owner에 room 필드를 추가해서 연결해 줄수도 있겠지만, django가 기본적으로 관계를 역으로 찾는 기능이 있다.

django는 \_set을 사용해서 연결된 모델을 찾아낸다.
\_set은 `a.model_set.all()` 형태로 사용하는데, 여기서 a가 역으로 탐지할 모델이고 model에 원본 모델을 적어주면 된다.
예를 들어서 user를 me라고 불러왔다고 하자.
그리고 room 모델과 user 모델이 연결되었을 때, me가 가지고 있는 room을 알아내려고 한다.
그러면 `me.room_set.all()`로 me가 연결된 모든 room을 출력할 수 있다.

위 호출 방법을 \_set을 쓰는 대신에 특정 명령어로 변경하는 것도 가능하다.
모델의 필드에서 related_name을 설정해주면 해당 명령어로 변경이 된다.
예를 들어서 owner 필드에 아래첢 related_name을 설정했다고 하자.

```python
  owner = models.ForeignKey(
    ...
    related_name="room"
  )
```

이제 \_set 없이도 관계를 역으로 찾을 수 있는데, `me.room.all()` 명령어로 찾을 수 있게 된다.
반대로 역으로 관계를 찾지 못하게 하는 것도 가능한데, related_name을 +로 끝나게 하는 것이다.

```python
  owner = models.ForeignKey(
    ...
    related_name="+"
  )
```

+로 바꾼 다음 `me.room_set.all()`을 입력해보면 동작하지 않는다.

#### ManyToManyField

#### OneToOneField

#### Customizing Users

앞서 우리는 Users를 만들어서 테스트를 했는데, 사실 장고는 기본적으로 사용자가 존재한다.
admin 페이지를 보면 우리가 만든 Users 모델 말고 다른 Users가 있는 것을 볼 수 있을 텐데, 이것이 바로 django의 기본 사용자다.
들어가서 확인해보면 이미 많은 내용이 만들어져 있는데, 우리가 사용자를 만들때 필요할만한 것들이 다 갖춰져있다.
그렇지만 여기서 몇 가지 변형이 필요한 경우가 있는데, 예를 들어 프로필 이미지를 추가하거나 포스팅 리스트가 필요할 수 있다.
이런 것을 추가하려면 django의 기본 Users를 커스터마이징할 필요가 있는데, 이는 2가지 방법으로 가능하다.

첫 번째는 Profile이라는 모델을 만들고, 그 안에 Users를 불러와서 쓰는 것이다.
이렇게 하면 Profile은 Users의 기능을 그대로 쓸 수 있고, Profile에 기능을 추가하면 간단히 해결된다.
두 번째 방법은 아예 우리가 만든 모델로 대체하는 것인데, django의 문서를 보면 2번째 방법을 강력히 추천한다.
그 이유는 프로젝트 중간에 방법을 바꾸기가 굉장히 어렵기 때문이다.
가급적 프로젝트가 시작될 때 커스텀 사용자를 만드는 것이 좋다.
그러므로 우리도 2번째 방법으로 사용자 커스터마이징을 해보겠다.

django는 기본적으로 많은 모델을 제공한다.
예를 들어서 django.contrib.auth는 User 모델을 가지고 있다.
여기엔 사용자 이름, 이메일, 비밀번호 등의 정보를 저장할 수 있다.
이 덕분에 우리는 모든 모델을 직접 만들 필요 없이, 주어진 모델을 사용할 수 있다.
하지만 User 모델은 형태가 정해져 있으므로 우리가 원하는 모델 구조와 다를 수 있다.
예를 들어 User에는 first name, last name이 필요한데, 우리가 사용할 모델은 하나의 name만 필요할 수 있다.
그러면 두 모델의 형태가 달라서 필요없는 부분이 생기고 이를 수정할 필요가 있다.
다시 말해 기본 모델로부터 커스텀 모델을 만들어야 한다.
이를 위해서 우리가 사용할 users 모델을 만들어 보겠다.

해결 방법은 2가지가 있다.
하나는 새로운 모델을 만들고 그 안에 User 모델과 연결시키는 것이다.
이 방법을 사용하면 User 모델은 그대로 있고, Profile 모델에 추가적인 정보를 저장할 수 있게 된다.
문제는 해결되겠지만 이후의 상황을 생각하면 그리 좋은 방법은 아니다.
새로운 변경이 생길 때마다 다시 새 모델을 만들고 이전의 모델을 연결시키는 작업을 반복하기 때문이다.
단계가 많아질수록 코드를 수정하기 어려워지고, 어디를 변경해야 할지 여러 모델을 찾아보며 고쳐야하게 된다.
그래서 우리는 2번째 방법을 사용한다.
다른 해결법은 모델을 불러와서 기능을 변경하는 것이다.
`python manage.py startapp users`로 users 폴더를 만든다.
그리고 models.py 파일에 아래처럼 작성한다.

```python
# models.py
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
  pass
```

위 파일은 auth.models의 AbstractUser 모델을 가져와서 이를 우리의 User 모델로 사용한 것이다.
cmd를 누른채로 AbstractUser를 클릭하면 파이썬 코드를 볼 수 있다.

장고에게 우리가 커스텀 모델을 사용한다는 것을 알려줘야 한다.
settings.py 파일을 열고 밑에 `AUTH_USER_MODEL = 'users.User'`를 추가한다.

```python
#settings.py
...
AUTH_USER_MODEL = 'users.User'
```

AUTH_USER_MODEL은 우리가 User로 어떤 모델을 사용할지 결정한다.
기본값은 auth.User이지만 우리는 직접 만든 User를 사용하기로 했으므로 users.User를 사용한다.
서버를 실행할때 만약 기존에 사용자가 존재했다면 에러가 발생한다.
이는 기존의 User과 지금의 User가 다른 모델을 사용하고 있기 때문에 발생한다.
해결하기 위해선 db.sqlite3를 삭제하고 각 모델 폴더에서 migrations 폴더에 들어간다.
그리고 0001_initial.py 같이 숫자로 넘버링된 파일을 모두 지워준다.
이때 migraions 폴더를 모두 지우는 것이 아니라 숫자가 붙은 파일만 지워야 한다.
그 후 `python manage.py makemigraions`으로 migration을 만들고 `python manage.py migrate`로 db를 업데이트 해준다.
모델은 admin에 등록하기 위해선 아래처럼 작성하면 된다.
이때 admin.ModelAdmin이 아니라 UserAdmin을 사용한 것에 주의하자.

```python
# users/admin.py
from django.contrib.auth.admin import UserAdmin
from .models import User

@admin.register(User)
class CustomUserAdmin(UserAdmin):
  pass
```

다시 User로 돌아가보자.
우리는 AbstractUser를 사용해서 커스텀 유저를 만들려고 한다.
그 말은 곧 AbstractUser의 속성을 없애거나, 덮어쓰거나, 추가하는 것을 말한다.
cmd를 누른채로 AbstractUser를 눌러서 코드를 보거나 앞서 적어놓은 코드를 보자.
first_name, last_name 이 존재하는데 우리는 이를 통일해서 name으로 사용하고 싶다고 하자.
간단한 방법은 소스 코드 자체를 수정하는 것이다.
그렇게 하면 우리 컴퓨터에서는 정상적으로 동작할 것이다.
하지만 서버에 배포하면 문제가 되는데, 서버는 일반적인 django를 가지고 실행하므로 소스코드가 수정되지 않은채로 작동한다.
또한 동료와 같이 작업할 때 소스 코드를 건드리면 변경 지점을 공유하기 어렵고, 다음에 다시 작업할 때 문제가 발생할 가능성이 높다.
그러므로 class에서 AbstractUser를 수정하는 방법을 알아보겠다.

#### Customizing Fields

우선 필요하지 않은 내용을 없애는 방법을 알아보자.
필드 중에서 없애고 싶은 내용에 *editable=False*를 적어주면 admin 페이지에도 해당 필드가 나오지 않고 수정이 불가능해진다.
예를 들어서 first_name과 last_name을 없애고 싶다면 패러메터에 editable=false를 추가한다.
이때 필수적으로 들어가야 하는 max_length는 반드시 존재해야 하므로, AbstractUser에서 코드를 복사한 다음 수정하는 것을 추천한다.

```python
# models.py
class User(AbstractUser):
  first_name = models.CharField(max_length=150, editable=False)
  last_name = models.CharField(max_length=150, editable=False)
```

원하는 필드를 추가하는 방법은 이전에 모델을 만드는 방법과 동일하다.

```python
class User(AbstractUser):
  first_name = models.CharField(max_length=150, editable=False)
  last_name = models.CharField(max_length=150, editable=False)
  name = models.CharField(max_length=150)
  is_host = models.BooleanField()
```

위처럼 모델을 만들고 `python manage.py makemigraions`로 migration을 만들면 에러 메세지가 나온다.

```
It is impossible to add a non-nullable field 'is_host' to user without specifying a default. This is because the database needs something to populate existing rows.
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
 2) Quit and manually define a default value in models.py.
Select an option:
```

에러 메세지는 is_host에 null 값이 들어갈 수 없는데, null 값이 들어갔다는 내용이다.
문제 발생 원인을 알아보려면 기존의 데이터 필드와 새로운 데이터 필드의 차이를 봐야 한다.
아래는 기존 데이터의 형태다.

| username | email          | first_name | last_name |
| -------- | -------------- | ---------- | --------- |
| testname | test@gmail.com | tester     | family    |

여기서 우리는 필드를 수정해서 아래처럼 만들었다.

| username | email          | first_name | last_name | name | is_host |
| -------- | -------------- | ---------- | --------- | ---- | ------- |
| testname | test@gmail.com | tester     | family    |      |         |

필드가 추가되면 기존의 데이터는 해당 필드에 null 값이 채워진채로 만들어진다.
여기서 is_host는 BooleanField인데 BooleanField는 True나 False 값만 들어갈 수 있다.
그런데 필드를 수정하면서 null 값이 들어갔으므로 에러가 발생하는 것이다.
에러 메세지는 해결 방법으로 2가지를 제시한다.
첫 번째는 default 값을 지정하는 것이다.
default 값을 지정하면 위처럼 필드 확장이 일어났을 때, null 대신에 default 값을 채워준다.
아래처럼 코드를 작성하고 migration을 만들면 django는 is_host에 False값을 채워줄 것이다.

```python
class User(AbstractUser):
  first_name = models.CharField(max_length=150, editable=False)
  last_name = models.CharField(max_length=150, editable=False)
  name = models.CharField(max_length=150)
  is_host = models.BooleanField(default=False)
```

두 번째 방법은 필드에 null 값을 허용하는 것이다.
문제는 BooleanField가 null을 사용할 수 없어서 발생하는 것이므로 *null=True*를 패러메터에 추가해 null값을 허용하도록 만들면 된다.

```python
class User(AbstractUser):
  first_name = models.CharField(max_length=150, editable=False)
  last_name = models.CharField(max_length=150, editable=False)
  name = models.CharField(max_length=150)
  is_host = models.BooleanField(null=True)
```

같은 이유로 name 필드에도 에러가 발생할텐데 둘 다 default 값을 지정해서 해결해보겠다.

```python
class User(AbstractUser):
  first_name = models.CharField(max_length=150, editable=False)
  last_name = models.CharField(max_length=150, editable=False)
  name = models.CharField(max_length=150, default="")
  is_host = models.BooleanField(default=False)
```

이제 `pyhton manage.py makemigrations`를 실행시키면 정상적으로 migration이 만들어진다.
하지만 admin/users/user 페이지에 들어가서 사용자를 확인해보면 에러가 발생하는데, first_name과 last_name을 editable=False로 지정해서 발생하는 문제다.
우리 admin.py 파일을 보면 UserAdmin을 사용하고 있는데, UserAdmin은 first_name과 last_name을 사용하고 있다.
django는 models에서는 둘을 수정할 수 없게 만들었지만, admin에서는 수정할 수 있게 만들었으므로 에러를 보여주는 것이다.
그러므로 admin.py에서 둘을 덮어쓰기해야 한다.
UserAdmin의 코드를 보면 fieldsets라는 항목이 있다.
fieldsets는 필드가 보이는 순서를 지정해줄 뿐만 아니라, 필드를 그룹화 할 수 있다.
우선 아래처럼 코드를 작성해보자.

```python
# admin.py
class CustomUserAdmin(UserAdmin):
  fieldsets = None
  field = ("email", "password", "name", "is_host")
```

위처럼 작성하고 admin 페이지에서 User를 확인하면 필드가 정상적으로 보인다.
그런데 필드의 항목이 늘어나서 서로 구분하고 싶은 경우가 있을 수 있다.
위의 내용을 하나의 Prifile이라는 항목에 추가하고 싶으면 fieldsets에 아래처럼 작성한다.
이때 ,를 사용하지 않으면 list나 tuple을 사용하지 않아서 에러가 나오니 주의하자.

```python
# admin.py
class CustomUserAdmin(UserAdmin):
    fieldsets = (
        (
            "Profile",
            {
                "fields": ("username", "email", "password", "name", "is_host"),
            },
        ),
    )
```

UserAdmin에는 그 외에도 Permission이나 Important Dates 같은 항목을 만들어뒀다.
이들도 필요하면 복사해와서 붙여넣으면 된다.
그 외에도 "classes": ("collapse")를 적으면 해당 섹션을 접을 수 있게 되고, "classes": ("wide")로 적으면 더 넓게 보인다.
정리하면 fieldsets는 field보다 더 많은 기능이 있다.
필드 내용을 섹션을 나눠서 정리할 수 있을 뿐더러, 섹션이 보이는 방법을 수정해서 보기 편하게 해준다.

admin/users/user 페이지로 돌아와보면 first_name과 last_name이 보이는데, 우리가 사용하지 않는 필드이므로 없애고 싶다.
이는 list_diaplay를 설정하는 것으로 가능한데, list_display는 원하는 column만 보이게 만든다.

```python
class CustomUserAdmin(UserAdmin):
    fieldsets = (
        ...
    )

    list_display = ("username", "email", "name", "is_host")
```

#### ImageField

User에 아바타용 이미지를 추가하는 필드는 *ImageField*로 만들 수 있다.
users/models.py에서 아래처럼 코드를 추가해준다.

```python
class User(AbstractUser):
  ...
  avatar = models.ImageField(blank=True)
```

그런데 서버를 실행시키면 에러가 발생할텐데 이는 Pillow가 없어서 발생하는 문제다.
파이썬에서 이미지를 사용하려면 Pillow라는 패키지를 설치해야 하는데, 우리는 poetry에 설치해줘야 하므로 `poetry add Pillow`로 패키지를 설치한다.
이렇게 만들면 이미지를 필수적으로 첨부해야 한다.
만약 이미지를 넣지 않게 하고 싶으면 `models.ImageField(blank=True)`를 적어줘야 한다.
blank=True와 null=True의 차이점은 blank는 말 그대로 빈 공간으로 놔둔다는 것이고, null은 null 값을 허용한다는 것이다.

#### Abstract base classes

모델을 만들다보면 공통적으로 가졌으면 하는 기능이 있을 것이다.
예를 들어서 생성 시간과 수정 시간은 모든 모델에게 필요하다.
공통된 모델을 만들기 위해 `python manage.py createapp common`로 common이라는 모델을 만든다.
그 후 settings.py에 아래처럼 common을 추가해준다.

```python
# settings.py
INSTALLED_APP = [
  ...
  "common.apps.CommonConfig",
]
```

그리고 common의 models.py 파일로 옮겨서 아래처럼 만든다.

```python
# models.py
from django.db import models

class CommonModel(models.Model):

    """Common Model Definition"""

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
      abstract = True
```

위에서 DateTimeField 필드는 시간을 관리하는 필드다.
여기에 auto_now_add와 auto_now를 설정했다.
auto_now_add는 모델이 생성된 시간을 기준으로 만들어진다.
반면 auto_now는 매번 모델이 수정된 시간을 기준으로 하므로 파일이 수정된 시간을 표시하는데 사용된다.
여기서 끝낸다면 django는 위 모델을 common이라는 새로운 모델이라고 생각하게 된다.
Meta 클래스에 *abstract=True*를 추가하면 모델을 만드는데 사용되지 않게 된다.
이제 이 모델을 기본으로 다른 모델을 만들면 공통으로 포함되는 모델을 만들 수 있다.
예를 들어 Room 모델에 models.Model 대신에 CommonModel을 추가하면 된다.

```python
from common.models import CommonModel

class Room(CommonModel):
  # This class includes created_at and updated_ad
  ...
```

### ORM(Object Relational Mapping)

데이터베이스는 SQL을 사용해서 관리하는데, 데이터를 엑셀 같은 테이블 형태로 저장한다.
그래서 각 데이터는 테이블의 한 칸을 차지하고 있고, ID와 Column을 가지고 그 값을 검색해낸다.
앞서 우리가 만든 데이터는 객체 구조로 이뤄져 있는데, 예를 들어서 room 모델은 안에 user 모델이 들어 있다.
그런데 이를 테이블 형태로 표현하려면 난감한다.
room의 owner 필드에 user가 들어가야 하는데, user가 테이블 형태여서 여러 칸을 필요로 하기 때문이다.
SQL에서 이를 직접 지정하고 관리할 수 있지만 그 과정에서 시간도 많이 걸리고 객체처럼 직관적으로 관계를 만들기 어렵다.
그래서 사람들은 ORM을 사용하는데, 간단히 말해 객체로 모델을 작성하면 SQL로 바꿔서 적용시켜주는 것이다.

#### [Queries](https://docs.djangoproject.com/en/4.1/topics/db/queries/#retrieving-objects)

지금까지는 admin 페이지를 이용해서 데이터를 생성, 삭제, 수정했다.
django는 직접적으로 데이터를 수정할 수 있다.
파이썬 코드를 직접 작성하고 실행해도 되지만, shell을 사용해서 즉각적으로 반응이 보이도록 예시를 들어보겠다.
우선 `python manage.py shell`로 shell 창을 연다.
여기서 모델을 불러와야 하므로 `from rooms.models import Room`을 한다.
그 후 Room 객체를 사용할 수 있게 되는데, 모든 객체를 표시하기 위해 `Room.objects.all()`을 입력해보자.
그러면 Room 모델의 데이터 정보가 나오게 된다.
이처럼 직접적으로 조작하는 경우 Model.objects를 사용한다.
사용가능한 기능은 all, get, create, save, filter, exclude 등이 있는데, 이름만 봐도 기능이 짐작될 것이다.
각 기능은 변수를 받아서 좀 더 정확한 일을 한다.
예를 들어서 get은 모델에서 일치하는 데이터를 찾기 위해 변수를 받아온다.
아래는 name이 location이 서울인 방을 찾는다.

```python
from rooms.models import Room
Room.objects.get(location="서울")
```

찾은 대상을 변수에 저장해서 다른 용도로도 사용가능하다.
all으로 모든 모델을 찾은 다음 내용을 for문으로 출력하는 것도 가능하다.

```python
Rooms = Room.objects.all()

for room in Room:
  print(room.name)
```

위에선 name만 출력했지만, id, owner, price 등의 다른 내용도 가져올 수 있다.
뿐만 아니라 해당 내용을 변경할 수 있고, save와 함께 사용하면 변경 내용을 저장할 수 있다.

```python
room = Room.objects.get(name="Beautiful House in 서울")
room.price = 20
room.save()
```

그 외에도 filter를 사용하면 조건에 맞는 모델만 찾을 수 있고, create로 생성하는 것도 가능하다.
다른 기능은 [Making queries](https://docs.djangoproject.com/en/4.1/topics/db/queries/#retrieving-objects)에서 볼 수 있다.

추가로 lookup을 설정할 수 있는데, lookup은 변수에 추가적인 조건을 다는 것이다.
예를 들어서 price가 20 이하인 방을 찾고 싶다고 하자.
앞서 배운 내용으로는 딱 20인 방을 찾을 순 있지만, 20 이하인 방을 찾을 순 없다.
이는 변수 뒤에 \_\_lte를 사용하는 것으로 가능한데, lte는 less then equal의 약자다.

```python
room = Room.obejcts.filter(price__lte=20)
```

특정 문자를 포함하고 싶으면 **contains를 사용하고, 값이 크길 원하면 **ge를 사용하는 등 여러 lookup이 있다.
자세한 내용은 위의 [Making queries](https://docs.djangoproject.com/en/4.1/topics/db/queries/#retrieving-objects)에서 검색해서 찾아보자.

### Admin

#### superuser

`python manage.py runserver`로 서버를 실행시킨 다음 http://localhost:8000/admin/에 들어가면 로그인 창이 뜬다.
아직 우리는 관리자 계정을 만들지 않았으므로 로그인 할 수 없지만, 이 페이지가 관리자 페이지로 앞으로 작성된 모델을 확인할 장소다.
관리자 계정을 만들기 위해 `python manage.py createsuperuser`를 입력해야 한다.
그런데 우리는 아직 마이그레이션을 적용하지 않아, 관리자 계정을 만들 수 없다.
마이그레이션이 무엇인지는 뒤에 설명할 것인데, 일단은 `pyhton manage.py migrate`로 마이그레이션을 적용한다.
그 후 username, email, password를 입력해 계정을 만든다.
`python manage.py runserver`로 서버 실행한 후, /admin 페이지로 이동한다.
그리고 관리자 계정으로 로그인하면 된다.
django administration 페이지가 나오는데, 여기서 우리는 이후에 추가될 모델을 볼 수 있을 것이다.

#### Admin register

이제 admin 페이지에서 위 내용을 확인해보겠다.
users/admin.py 파일로 이동해서 아래처럼 작성한다.

```python
# users/admin.py
from django.contrib import admin
from .models import User

# Register your models here.

@admin.register(User)
class UserAdmin(admin.ModelAdmin):
  pass
```

다시 admin 페이지에 들어가보면 Users라는 모델이 있다.
하지만 클릭해보면 에러메세지가 나오는데 이는 아직 마이그레이션을 적용하지 않았기 때문이다.

그런데 admin 페이지를 보면 houses 모델이 없다.
이는 아직 우리가 admin.py에 모델을 추가해주지 않아서 생기는 문제다.
모델을 추가하려면 역시 class를 만들어야 하는데 django.contrib.admin.ModelAdmin을 상속받아야 한다.
내부에 변경점은 없으므로 pass를 적어준다.
그후 class 위에 `@admin.register(House)`라고 적어준다.
@admin.register은 바로 아래의 클래스를 확인해서 해당 모델을 admin에게 추가해준다.
다른 방법으로는 admin.site.register를 사용하는 것인데, 이 방법은 등록될 모델과 클래스를 같이 적어줘야 하는 번거로움이 있다.
예를 들어서 아래는 House 모델을 admin에 등록하는 2가지 방법이다

```python
from django.contrib import admin
from .models import House

@admin.register(House)
class HouseAdmin(admin.ModelAdmin):
  pass

# or
class HouseAdmin(admin.ModelAdmin):
  pass

admin.site.register(House, HouseAdmin)
```

@admin.register 방식이 더 간편하므로 이를 사용하는 것이 더 좋다.

```python
# admin.py
from django.contrib import admin
from .models import House

# Register your models here.

@admin.register(House)  #decorator
class HouseAdmin(admin.ModelAdmin):
  pass
```

admin 페이지에서 에러가 나는 경우는 migration을 만들고 migrate한 다음 들어가보자.

#### Admin Customizing

다시 admin 페이지에 들어가서 Users를 보자.
오른쪽 위를 보면 ADD USER 버튼으로 사용자를 추가할 수 있는데, 적절히 입력해서 하나 만들어준다.
그런데 admin 페이지를 보면 그다지 쓸모 있는 정보가 많지 않다.
admin 페이지는 원하는대로 커스터마이징이 가능하다.
admin에서 보여줄 내용은 admin.py 파일에 작성해야 한다.
우선 모델을 추가할 때 사용하는 폼을 수정해보자.
fields 라는 항목을 추가하고 필드를 적어주면 원하는대로 순서를 변경할 수 있다.
예를 들어서 아래처럼 하고 새로 사용자를 추가하려 하면, 폼에서 필드 순서가 바뀌었을 것이다.

```python
# admin.py
from django.contrib import admin
from .models import User

@admin.register(User)
class UserAdmin(admin.ModelAdmin):
  fields = (
    "join_date",
    "description",
    "name",
    "email",
  )
```

폼을 구간별로 나누려면 fieldsets을 사용할 수 있다.

```python
# admin.py
@admin.register(User)
class UserAdmin(admin.ModelAdmin):
  fieldsets = (
    (None, {'fields': ('name', 'email', "description")}),
    ('Date information', {'fields': ['join_date']}),
  )
```

그 외에도 모델을 보여주는 창도 수정할 수 있다.
기본적으로 django는 \_\_str\_\_ 메서드의 값을 보여준다.
그러므로 str을 수정하는 것으로 이름을 바꿀 수 있다.
models.py 파일로 이동해 아래처럼 수정해보자.

```python
from django.db import models

# Create your models here.

class User(models.Model):
  ...
  def __str__(self):
    return self.name

```

다시 Users 모델을 보면, 각자 자신의 이름을 보여주게 된다.
그 외에도 안의 필드 내용을 보여주면 유용할 것이다.
list_display는 어떤 필드를 보여줄지 정하고, list_filter는 대상으로 필터링 가능하게 만들어준다.
search_fields는 검색창을 만들어주는 등 admin 페이지를 원하는대로 변경 가능하다.

```python
# admin.py
@admin.register(User)
class UserAdmin(admin.ModelAdmin):
  ...
  list_display = ('name', 'join_date')
  list_filter = ('join_date',)
  search_fields = ('name',)
```

list_diaply를 추가하면 column이 생긴 것을 볼 수 있고, list_filter는 필터링 목록이 생겼고, search_fields로 검색챙이 생겼다.
이때 tuple을 사용하면 주의할 사항이 하나 있다.
tuple의 원소가 하나일때도 뒤에 ,를 꼭 붙여줘야 정상적으로 작동한다.

#### Choices

필드에 정해진 값에서 선택할 수 있게 만들려면 Choices를 사용한다.
Choices는 tuple을 사용해서 만드는데 아래처럼 만든다.

```python
YEAR_IN_SCHOOL_CHOICES = [
    ('FR', 'Freshman'),
    ('SO', 'Sophomore'),
    ('JR', 'Junior'),
    ('SR', 'Senior'),
    ('GR', 'Graduate'),
]
```

여기서 좌측값(FR, SO, JR 등)이 모델에서 선택할 수 있는 값이고, 오른쪽은 admin에서 보게될 값이다.
예를 들어서 값을 JR로 정했다면 admin에서는 Junior로 표시된다.

Choices는 모델 클래스 안에서 만들어서 사용해야 편한데, 수정할 일이 있으면 해당 모델 안에서 모두 확인할 수 있기 때문이다.
아래는 CharField에 choices를 적용한 것이다.

```python
from django.db import models

class Student(models.Model):
  YEAR_IN_SCHOOL_CHOICES = [
    ('FR', 'Freshman'),
    ('SO', 'Sophomore'),
    ('JR', 'Junior'),
    ('SR', 'Senior'),
    ('GR', 'Graduate'),
  ]
    year_in_school = models.CharField(
        max_length=2,
        choices=YEAR_IN_SCHOOL_CHOICES,
        default=FRESHMAN,
    )
```

다른 방법으로 하위 클래스를 만드는 방법이 있다.
하위 클래스를 사용하면 열거하는 방식으로 만들 수 있는데, 괄호 없이 만들 수 있게 된다.
하위 클래스는 TextChoices를 사용하는데 아래처럼 적어준다.

```python
from django.db import models

class Student(models.Model):

  class YearInSchool(models.TextChoices):
    FRESHMAN = ('FR', 'Freshman')
    SOPHOMORE = ('SO', 'Sophomore')
    JUNIOR = ('JR', 'Junior')
    SENIOR = ('SR', 'Senior')
    GRADUATE = ('GR', 'Graduate')

  year_in_school = models.CharField(
      max_length=2,
      choices=YearInSchool.choices,
      default=FRESHMAN,
  )
```

다음으로 admin.py에서 이를 적용해줘야 하는데, fields에 year_in_school을 추가해주면 된다.

#### Meta

모델을 만들다보면 필드가 아닌 항목도 만들게 된다.
예를 들어서 admin 페이지에서 복수형을 수정하고 싶다거나, 테이블 이름을 바꾸고 싶거나, 순서를 변경하는 등의 일이 필요하다.
이처럼 필드 이외의 항목을 수정하는 것은 하위 클래스의 Meta를 수정하는 것으로 가능하다.
예를 들어서 admin 페이지를 보면 모델을 자동으로 복수형으로 바꿔준다.
User는 Users가 되고 Room은 Rooms가 된다.
하지만 복수형은 예외가 많은데, 대표적으로 Amenity는 복수형이 Amenities다.
admin 페이지는 이를 인식하지 못하므로 Amenitys가 된다.
물론 별다른 문제점은 없겠지만 해결하는 것이 좋다.
Meta의 verbose_name_plural을 수정하면 복수형을 바꿀 수 있다.
아래는 Amenity 모델의 복수형을 수정한 것이다.

```python
class Amenity(models.Model):
  ...
  class Meta:
    verbose_name_plural = "Amenities"
```

#### \_\_str\_\_

모델에서 소유자를 ForeignKey를 사용하고 있으므로, admin 페이지에서 ID로 표시된다.
그런데 ID로 표시되기 보다 소유자의 이름으로 표시되면 더 보기 좋을 것이다.
admin 페이지는 \_\_str\_\_에서 반환되는 값을 보여준다.
예를 들어서 아래처럼 수정하면 ID 대신에 name을 보여준다.

```python
# rooms/models.py
class Room(models.Model):
  ...
  def __str__(self):
    return self.name
```

#### Admin Methods

admin 페이지에서 모델의 총 수를 보여주는 것은 꽤나 유용하므로, 이번에는 모델의 수를 보여주는 필드를 만들겠다.
amenities의 수를 표시하는 필드를 total_amenities라고 하겠다.
admin 페이지에서 보여줘야 하므로 list_display에 추가해준다.
그리고 total_amenities를 정의해주면 되는데 크게 2가지 방법이 있다.
첫 번째는 admin.py 파일에 total_amenities를 선언하는 것이다.
이 경우 클래스 안에 total_amenities 메소드를 선언하고 count를 사용해서 그 수를 반환하면 된다.
다른 방법은 models.py 파일에서 메소드를 선언하는 것이다.
두 방법은 그다지 차이가 없지만 원본 모델을 admin으로 가져와서 보여줄 것인지, 아니면 모델의 하위 메소드로 선언할지의 차이다.
admin 페이지에서만 수를 출력할 필요가 있다면 admin.py 파일에 추가하는 것이 더 자연스럽고, 다른 곳에서도 사용한다면 모델에서 선언하는 것이 좋다.

```python
# rooms.admin.py
  list_display = (
    ...
    "total_amenities",
  )

# To display number of amenities on admin page.
# There are two ways to show that.
# First is write method on RoomAdmin

  def total_amenities(self, room):
    return room.amenities.count()

# or you can write down on models.py like below

# models.py
class Room(models.Model):
  ...
  def total_amenities(self):
    return self.amenities.count()

```

#### Search Fields

search_fields = (
"name",
"price",
)

#### @admin.action

### View

view는 URL을 기반으로 코드를 실행해준다.

```python
# polls/views.py
from django.http import HttpResponse

def index(request):
    return HttpResponse("This is polls")
```

```python
# config/urls.py
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
  path("polls/", views.index),
  path("admin/", admin.site.urls),
]
```

View를 호출하려면 연결된 URL이 필요한데, URLconf로 이어준다.
urls.py라는 파일을 생성하고 아래처럼 작성한다.

```python
# polls/urls.py
from django.urls import path

from . import views

urlpatterns = [
  path("", views.index, name="index"),
]
```

다음으로 config 폴더의 urls.py를 열고 아래처럼 include 시킨다.

```python
# config/urls.py
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
  path("polls/", include("polls.urls")),
  path("admin/", admin.site.urls),
]
```

include는 다른 URLconf를 참조할 수 있도록한다.
django는 include를 만나면 URL에서 지금까지 일치하는 점은 잘라내고, 남은 문자열을 URLconf로 전달한다.

서버를 실행하고 페이지에 들어가면 View에서 작성한 내용이 보인다.

path는 route, view를 인수로 사용한다.
route에는 URL 패턴을 적고, 일치하는 패턴을 찾으면 view에 전달한다.

#### URL Arguments

url에 변수를 포함하려면 <type:var>형태로 입력하면 된다.
예를 들어서 id를 정수값으로 사용하고 싶으면 <int:id>로 적어서 아래처럼 사용한다.

```python
# polls/urls.py
from django.urls import path

from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('<int:id>/', views.detail, name='detail'),

]
```

여기서 url에 적힌 변수는 view 파일에서 아래처럼 변수로 받아서 사용한다.

```python
# polls/views.py
def detail(request, id):
    return HttpResponse("You're looking at question %s." % id)
```

### Template

django를 DB관리와 API 용으로 사용하고, 프론트는 React로 만들 생각이라면 이 항목은 읽지 않아도 된다.
Template는 django에서 HTML로 페이지를 만들게 해준다.
이때 정적인 부분만 Template로 만들고 동적인 부분은 View에서 만들어 기능과 디자인을 구분해야 편하게 만들 수 있다.
polls 폴더에 templates 폴더를 만들고 polls.html 파일에 아래처럼 적어준다.

```python
# polls/templates/polls.html
{% if latest_question_list %}
    <ul>
    {% for question in latest_question_list %}
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}
```

위 코드를 보면 짐작하겠지만 HTML과 파이썬 코드를 혼용하고 있다.
이때 파이썬 코드는 {%%} 안에 적어줘야 하는데, 일반적인 파이썬 코드와 달리 {% endfor %}처럼 for문이 종료되는 위치를 적어줘야 한다.
간단하게 말해 HTML의 태그가 열리고 닫히듯이 파이썬 코드를 사용해야 한다는 의미다.

이제 위에서 만든 파일을 View에서 보여주려고 한다.
loader를 사용하는 방법과 render를 사용하는 방법이 있는데 각각의 장단점이 있다.

#### loader

django.template.loader를 사용해서 페이지를 불러올 수 있다.
이때 사용하는 변수는 context 내에 적어준다음 render에 전달해줘야 한다.

```python
# polls/views.py
from django.http import HttpResponse
from django.template import loader

from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    template = loader.get_template('polls.html')
    context = {
        'latest_question_list': latest_question_list,
    }
    return HttpResponse(template.render(context, request))
```

#### render

그런데 위처럼 Template를 사용하는 방법은 꽤나 자주 사용되므로, 좀 더 간결하게 render만으로 페이지를 만들 수 있게 되어있다.
loader과 HttpResponse를 사용하지 않고 아래처럼 적어줘도 같은 페이지가 나온다.

```python
# polls/views.py
from django.shortcuts import render

from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_question_list': latest_question_list}
    return render(request, 'polls/index.html', context)
```

보다시피 render이 훨씬 간결하고 보기 좋다.
그럼에도 HttpResponse의 속성을 사용해야할 경우엔 HttpResponse를 사용해야 한다.

보다시피 Template를 사용한 방법은 완전히 HTML로 만들어야 한다.
이는 물론 정적인 페이지나 간단한 결과를 보여주고 싶을 때, 사용하기 좋다.
그렇지만 대부분은 Template를 사용하지 않는다.
대신 React로 프론트 작업을 한다음 API로 django와 연결하는 방법을 많이 사용한다.

## Django REST Framework

Django REST Frmawork는 REST API를 쉽게 만들게 해준다.
REST API가 무엇인지는 이미 다른 포스트에 정리했으므로 넘어가겠다.
그런데 왜 REST API가 필요한 것일까?
앞서 우리는 Template를 만들어서 웹 페이지를 보여주는 방식을 배웠다.
간단한 페이지는 이렇게 HTML로 만들기 쉽지만, 좀 더 복잡한 페이지에선 React를 사용하길 원한다.
그렇다면 django는 HTML 대신에 필요한 정보를 JSON으로 전달해줘야 하고, 이는 곧 API를 사용해야 한다는 의미다.
프론트 앱에서 서버 API에 데이터를 요청하고 이를 바탕으로 페이지를 그리게 만들어줄 것이다.

`poetry add djangorestframework`

```python
# config/settings.py
INSTALLED_APPS = [
  ...
  'rest_framework',
]
```

### Without REST Framework

REST framework를 사용하기 전에 기본적인 django로만 api를 만들어보자.
물론 이는 충분히 가능한데, django가 기본적으로 JSON Response를 지원하기 때문이다.
우선 categories/라는 URL로 들어왔을 경우 category 모델을 모두 보여주려고 한다.
이를 위해 config/urls.py에 주소를 만들어준다.

```python
# config/urls.py
...
urlpatterns = [
  ...
  path("categories/", include("categories.urls")),
]
```

그 후 urls.py에 views 파일 내의 categories를 응답으로 보내도록 만든다.

```python
# categories/urls.py
from django.urls import path
from . import views

urlpatterns = [
  path("", views.categories),
]
```

이제 views 파일을 작성해야 하는데, django.http의 JsonResponse로 JSON 응답을 할 수 있다.
ORM으로 Category 모델의 정보를 모두 불러와서 JSON 응답으로 전달하려면 아래처럼 하면 될 것이다.

```python
# categories/views.py
from .models import Category
from django.http import JsonResponse

def categories(request):
  all_categories = Category.objects.all()
  return JsonResponse(
    {
      "ok": True,
      'categories': all_categories,
    }
  )
```

그런데 서버를 실행하고 /categories에 접속하면 에러가 발생한다.
에러를 읽어보면 "QuerySet is not JSON serializable"이라 나오는데 무슨 의미일까?
앞서 우리는 ORM을 사용해 Category 모델을 불러와 all_categories로 저장했다.
그러므로 all_categories는 QuerySet인데, 문제는 우리가 이를 JsonResponse로 보내려고 해서 발생한다.
즉, QuerySet을 JSON으로 보내려고 했기 때문에 타입이 맞지 않아서 에러가 발생한 것이다.
이를 해결하려면 QuerySet을 JSON으로 번역해주는 기능이 필요하다.

### serializer

django는 django 모델을 다른 포맷으로 변경해주는 serializer를 기본적으로 내포하고 있다.
우리가 할 일은 그저 serializer를 불러와서 어떤 데이터로 바꿔줄지 정하는 것이다.

```python
# views.py
...
from django.core import serializers

def categories(request):
  ...
    return JsonResponse(
    {
      ...
      'categories': serializers.serialize("json", all_categories),
    }
  )
```

이로써 QuerySet을 JSON으로 변경하는데 성공했다.
그런데 매번 view에러 serializer를 일일이 사용해야 하는 번거로움이 있다.
또한 QuerySet에서 특정 내용만 보여주고 싶으면 어떻게 해야 할까?
예를 들어서 PK를 숨기고 싶다거나, updated_at을 보여주고 싶지 않은 경우가 있다.
문제는 django의 serializer이 이런 기능이 없다는 것이다.
serializer는 굉장히 기본적인 기능만 갖추고 있으므로, 저런 편의성 있는 기능이 없고, 우리가 직접 코드를 작성해야 한다.

#### GET

이 시점에서 REST Framework를 사용해보겠다.
일단은 아래 내용을 그대로 적어보자.

```python
# views.py
...
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view()
def categories(request):
  return Response(
    {
      "ok": True,
    }
  )
```

그 후에 서버를 실행시켜 /categories 페이지를 확인해보면, 웹 페이지가 보일 것이다.
REST Framework는 @api_view를 사용했을때, 응답을 멋들어지게 보여주는 웹 페이지를 보여준다.
요청, URL, HTTP 응답, 헤더 정보 등 다양한 내용이 보기 좋게 정렬되어 있다.
물론 이는 개발자인 우리만 볼 수 있는 페이지로, 실제 사용자는 JSON 정보만을 받게 될 것이다.

이제 QuerySet을 JSON으로 바꿀 serializer가 필요하다.
serializers.py 파일을 만들고, serializers.Serializer 모델을 상속 받는다.
그리고 그 안에 어떤 필드를 보여줄지 적어야 하는데, 필드명과 타입을 맞춰 적어야 한다.
예를 들어 아래는 Category 모델에서 name과 kind만 보여줄 것이다.

```python
# serializers.py
from rest_framework import serializers

class CategorySerializer(serializers.Serializer):
  name = serializers.CharField(required=True)
  kind = seriszlieres.CharField()
```

```python
# views.py
...
from .serializers import CategorySerializer

@api_view()
def categories(request):
  all_categories = Category.objects.all()
  serializer = CategorySerializer(all_categories, many=True) # many=True가 없으면 하나만 번역하므로 에러가 발생한다.
  return Response(
    {
      "ok": True,
      "categories": serializer.data,
    }
  )
```

추가로 타입을 변형하는 것도 가능한데, 예를 들어서 pk가 모델에서는 integer일지라도 출력되는 결과는 string으로 만들 수 있다.

```python
# serializers.py
...
class CategorySerializer(serializers.Serializer):
  ...
  pk = serializers.CharField() # or pk = serializers.IntegerField()
```

```python
# urls.py
urlpatterns = [
  ...
  path("<int:pk>", views.category),
]
```

```python
# views.py
...
@api_view()
def category(request, pk):
  category = Category.objects.get(pk=pk)
  serializer =  CategorySerializer(category)
  return Response(serializer.data)
```

#### POST

지금까지는 GET 요청만을 받았는데, 이번에는 POST 요청을 받게 만들겠다.
@api_view에 허락할 요청을 적어주기만 하면 된다.

```python
# views.py
...
@api_view(["GET", "POST"])
def category(request, pk):
  category = Category.objects.get(pk=pk)
  serializer =  CategorySerializer(category)
  return Response(serializer.data)
```

위와 같이 수정하고 페이지에 가보면 아래에 폼이 생겼을 것이다.
아래 폼을 사용하면 POST 요청을 페이지에서 보낼 수 있게 된다.
물론 우리는 POST 요청을 위한 내용을 작성하지 않았으므로 GET과 같은 결과가 나올 것이다.
request의 method를 확인해서 요청에 따라 행동을 바꿔보자.

```python
# views.py
@api_view(["GET", "POST"])
def categories(request):
  if request.method == "GET":
    all_categories = Category.objects.all()
    serializer = CategorySerializer(all_categories, many=True)
    return Response(
      {
        "ok": True,
        "categories": serializer.data,
      }
    )
  elif request.method == "POST":
    print(request.data)
    return Response(
      {
        "created": True
      }
    )
```

페이지에서 폼으로 POST 요청을 보내면 데이터가 출력될 것이다.
그렇지만 우리는 POST 요청시에 새로운 데이터를 만들어야 한다.
이는 ORM의 create로 가능하고 아래처럼 하면 될 것이다.

```python
# views.py
@api_view(["GET", "POST"])
def categories(request):
  ...
  elif request.method == "POST":
    Category.objects.create(
      name=request.data["name"],
      kind=request.data["kind"],
    )
    return Response(
      {
        "created": True
      }
    )
```

그런데 우리가 모델을 만들 때 작성했던 제약들을 검증해야 한다.
예를 들어 name은 40글자 아래여야 하는데, 위처럼 만들면 모델의 제약과 달라서 문제가 발생할 것이다.
물론 이는 name의 길이를 체크하고 이상이 있으면 응답으로 에러 메세지를 보내면 된다.
그런데 필드가 20가지 항목이 있다면, 각각의 항목을 모두 체크해야 하므로 해야할 일이 굉장히 많아질 것이다.
이처럼 1가지 모델을 작성하는데만도 너무 많은 노력이 들고 있다.

여기서 밝혀야할 사실이 있는데 사실 serializer는 QuerySet을 JSON으로 번역해주는 도구가 아니다.
serializer는 반대로 JSON에서 QuerySet으로 바꿀 수 있다.
즉, serializer는 QuerySet과 JSON 사이의 양방향 변환을 가능하게 해준다.
이로 인해 우리는 작성한 JSON을 모델로 쉽게 바꿀 수 있다.
물론 그 전에 데이터가 모델에 맞는지 검증할 필요가 있다.
검증은 그냥 serializers에 데이터를 건네주면 되는데, 이때 data 변수로 전달해야 한다.
앞서 QuerySet => JSON 시에는 그냥 1번째 변수로 넘겨주면 됐지만, 반대의 경우는 data에 있는 내용을 사용하므로 주의하자.

```python
# views.py
@api_view(["GET", "POST"])
def categories(request):
  ...
  elif request.method == "POST":
    serializer = CategorySerializer(data=request.data)
    return Response(
      {
        "created": True
      }
    )
```

앞서 우리가 serializers.py에 작성한 내용을 보면, 각 필드에 어떤 제약이 있는지 적어줬다.
serializer는 이에 따라 데이터를 검증해준다.
물론 serializers.py 파일에 적혀있지 않으면 체크할 수 없으므로, 모델을 보고 제약 사항을 그대로 가져오는 것이 중요하다.
serializer로 받아온 내용이 모델과 맞는지 아닌지는 is_valid로 알 수 있다.

```python
# views.py
@api_view(["GET", "POST"])
def categories(request):
  ...
  elif request.method == "POST":
    serializer = CategorySerializer(data=request.data)
    print(serializer.is_valid())
    return Response(
      {
        "created": True
      }
    )
```

그런데 serializer는 필요한 모든 데이터를 받아올 것이라 예측하므로 정보가 부족하면 false를 반환한다.
어떤 에러가 발생했는지는 errors로 볼 수 있다.

```python
# views.py
@api_view(["GET", "POST"])
def categories(request):
  ...
  elif request.method == "POST":
    serializer = CategorySerializer(data=request.data)
    print(serializer.is_valid())
    print(serializer.errors)
    return Response(
      {
        "created": True
      }
    )
```

그런데 pk나 created_at은 사용자로부터 입력받을 필요가 없는 내용임에도 에러를 발생시킨다.
간단하게 read_only=True를 추가하면 해결된다.

```python
# serializers.py
...
class CategorySerializer(serializers.Serializer):
  pk = serializers.CharField(read_only=True)
  ...
  created_at = serializers.DateTimeField(read_only=True)
```

시험하기 전에 코드를 아래처럼 고치자.

```python
# views.py
@api_view(["GET", "POST"])
def categories(request):
  ...
  elif request.method == "POST":
    serializer = CategorySerializer(data=request.data)
    if serializer.is_valid():
      return Response({"created": True})
    else:
      return Response(serializer.errors)
```

이제 에러가 발생하면 에러가 반환되고 아니면 생성 응답이 나온다.

serializer는 choice 같은 제약도 정할 수 있다.
choices 항목에 적어주면 되는데, 아래처럼 하면 된다.

```python
# serializers.py
from .models import Category

class CategorySerializer(serializers.Serializer):
  ...
  kind = serialisers.ChoiceField(
    ...
    choices = Category.CategoryKindChoices.choices,
  )
  ...
```

serializer를 사용해서 데이터를 생성하려면 serializer.save를 사용해야 한다.
serializer.save는 serializer가 정의된 곳에서 create 메서드를 찾아 실행시킨다.
우선 views.py에 새로운 데이터를 생성하도록 serializer.save를 사용한다.

```python
# views.py
@api_view(["GET", "POST"])
def categories(request):
  ...
  elif request.method == "POST":
    serializer = CategorySerializer(data=request.data)
    if serializer.is_valid():
      serializer.save()
      return Response({"created": True})
    else:
      return Response(serializer.errors)
```

그 다음 serializers.py 파일로 이동해서 create 메서드를 만든다.
create 메서드는 validated_data에 정보를 받아온다.
이 값을 사용해 objects.create로 데이터를 생성하면 된다.

```python
# serializers.py
class CategorySerializer(serializers.Serializer):
  ...
  def create(self, validated_data):
    return Category.objects.create(
      name=validated_data['name'],
      kind=validated_data['kind'],
    )
```

여기서 validated_data가 상당히 큰 경우 위처럼 일일이 적어주는건 낭비다.
그러므로 \*\*를 사용해 객체를 펼쳐주면 간단하게 해결된다.

```python
# serializers.py
class CategorySerializer(serializers.Serializer):
  ...
  def create(self, validated_data):
    return Category.objects.create(**validated_data)
```

주의할 점은 create가 반드시 객체를 반환해야 한다는 점이다.
그러므로 위처럼 생성된 데이터를 반환해야 한다.
마지막으로 반환된 데이터를 다시 JSON 형태로 변환해야 하므로 CategorySerializer를 다시 사용해서 반환해준다.

```python
# views.py
@api_view(["GET", "POST"])
def categories(request):
  ...
  elif request.method == "POST":
    serializer = CategorySerializer(data=request.data)
    if serializer.is_valid():
      new_category = serializer.save()
      return Response(
        CategorySerializer(new_category).data,
      )
    else:
      return Response(serializer.errors)
```

#### Update

업데이트를 하려면 PUT 명령을 사용해야 하므로, @api_view에 PUT을 추가하면 된다.
업데이트 대상을 찾아야 하므로 pk로 카테고리를 검색해야 한다.
그 후 요청에 따라서 코드를 나눠야 한다.
편의를 위해 GET과 PUT만 구분해줬다.

```python
# views.py
@api_view(["GET", "PUT"])
def category(request, pk):
  category = Category.objects.get(pk=pk)
  if request.method == "GET":
    serializer = CategorySerializer(category)
    return Response(serializer.data)
  elif request.method == "PUT":
    # Write code here
```

그런데 요청한 pk에 맞는 카테고리가 없을 수도 있으므로 이를 try/except로 예외 처리해줘야 한다.
이때 rest_framework의 NotFound를 사용했다.

```python
# views.py
from rest_framework.exceptions import NotFound

@api_view(["GET", "PUT"])
def category(request, pk):
    try:
      category = Category.objects.get(pk=pk)
    except Category.DoesNotExist:
      raise NotFound
  if request.method == "GET":
    serializer = CategorySerializer(category)
    return Response(serializer.data)
  elif request.method == "PUT":
    # Write code here
```

이제 남은 것은 업데이트시의 코드를 작성하는 것뿐이다.
업데이트시에도 serializer를 사용한다.
serializer는 건네주는 변수의 갯수에 따라 다르게 반응한다.
첫번째 변수로 데이터를 넘겨주면 포맷 변경이라 인식하고, data로 넘겨주면 POST로 생각한다.
그리고 둘 다 넘겨주면 PUT이라 생각한다.
이때 첫 번째 변수는 원본 데이터고 data로 넘기는 정보는 업데이트 할 내용이 된다.

```python
# views.py
@api_view(["GET", "PUT"])
def category(request, pk):
  ...
  elif request.method == "PUT":
    serializer = CategorySerializer(
      category,
      data=request.data,
    )
```

그런데 위와 같이 넘겨주면 모든 필드의 내용을 data에 적어줘야 한다.
만약 적혀진 내용만 변경하고 싶으면 serializer에 partial=True를 사용해야 한다.

```python
# views.py
@api_view(["GET", "PUT"])
def category(request, pk):
  ...
  elif request.method == "PUT":
    serializer = CategorySerializer(
      category,
      data=request.data,
      partial=True,   # 일부 내용만 변경시에 사용
    )
```

아직 우리는 update에 관한 코드를 작성하지 않았지만, 위 코드가 정상적으로 동작했으면 serializer에 바뀐 내용이 들어 있을 것이다.
REST Framework는 이 내용이 모델의 필드와 맞는지 검증해주는 is_valid가 포함되어 있으므로 이를 사용해 이상이 없는지 확인한다.
그리고 다시 포맷을 변환하는데 serializer를 사용해서 반환하도록 한다.

```python
# views.py
@api_view(["GET", "PUT"])
def category(request, pk):
  ...
  elif request.method == "PUT":
    serializer = CategorySerializer(
      category,
      data=request.data,
      partial=True,
    )

    if serializer.is_valid():
      updated_category = serializer.save()
      return Response(CategorySerializer(updated_category).data)
    else:
      return Response(serializer.errors)
```

이제 serializer에서 update가 일어날 때 동작할 코드를 작성해보자.
앞서 말했듯이 serializer에 원본 데이터와 바뀔 data가 동시에 주어지면 update 메서드가 실행된다.
아래는 update의 형태다

```python
# serializers.py

def update(self, instance, validated_data):
  ...
```

여기서 instance에는 원본 데이터가 들어 있고, validated_data에는 변경될 내용이 들어 있다.
문제는 validated_data에 필요한 내용이 없을 수도 있다.
예를 들어 name이 없는데 무작정 업데이트 시켜선 안 될 것이다.
그러므로 아래처럼 코드를 작성했다.

```python
# serializers.py

def update(self, instance, validated_data):
  if validated_data['name']:
    instance.name = validated_data['name']
  ...
```

그런데 위와 같이 필드를 계속 검사하는 일은 번거롭다.
그러므로 .get을 사용할텐데, get은 찾는 내용이 없으면 2번째로 받는 패러미터를 반환한다.
이를 사용해 위 코드를 아래처럼 고쳤다.

```python
# serializers.py

def update(self, instance, validated_data):
  instance.name = validated_data.get("name", instance.name)
  instance.kind = validated_data.get("kind", instance.kind)
```

위와 같이 작성하면 validated_data에 항목이 없더라도 instance의 값을 꺼내와서 사용할 것이다.
모든 내용이 변경되었으면 instance를 저장하고 반환한다.

```python
# serializers.py

def update(self, instance, validated_data):
  instance.name = validated_data.get("name", instance.name)
  instance.kind = validated_data.get("kind", instance.kind)
  instance.save()
  return instance
```

#### DELETE

삭제는 굉장히 간단하다.
@api_view에 DELETE를 추가해준다.
그리고 DELETE 명령일 결우 delete 메소드로 카테고리를 지운다.
마지막으로 status code는 200, 202, 204 중에 하나를 선택하면 된다.
status code는 rest_framework.status에서 가져오면 된다.

```python
# views.py
from rest_framework.status import HTTP_204_NO_CONTENT

@api_view(["GET", "PUT", "DELETE"])
def category(request, pk):
  ...
  elif request.method == "DELETE":
    category.delete()
    return Response(status=HTTP_204_NO_CONTENT)
```

#### API View

우리 코드를 보면 HTTP method를 체크한 후에 if-else로 계속 나눠주고 있다.
이는 가독성도 좋지 않고 여러모로 불편하므로, REST Framework는 API View class로 이를 해결한다.
rest_framework.views에서 APIView를 가져온다.
그리고 이를 상속 받아서 클래스를 만드는데, HTTP method를 메소드로 만들면 해당 api를 만들 수 있다.
예를 들어 get 메소드를 작성하면 GET 요청시에 실행될 API를 만들 수 있다.

```python
# views.py
from rest_framework.views import APIView

class Categories(APIView):
  def get(self, request):
    # Write GET API on here

  def post(self, request):
    # Write POST API on here
```

이렇게 API를 만들면 url에서도 이름을 바꿔줘야 한다.
이때 클래스를 가져오므로 뒤에 .as_view()를 추가해야 한다.

```python
# urls.py
urlpatterns = [
  path("", views.Categories.as_view()),
  ...
]
```

기존 방법과의 차이점은 method를 체크하고 if-else로 나누는 대신에 메소드로 나눈다는 점, 그리고 클래스를 사용한다는 점이다.
우선 Categories를 수정하면 아래처럼 된다.

```python
# views.py
from rest_framework.views import APIView

class Categories(APIView):
  def get(self, request):
    all_categories = Category.objects.all()
      serializer = CategorySerializer(all_categories, many=True)
      return Response(serializer.data)

  def post(self, request):
    serializer = CategorySerializer(data=request.data)
    if serializer.is_valid():
        new_category = serializer.save()
        return Response(
            CategorySerializer(new_category).data,
        )
    else:
        return Response(serializer.errors)
```

마찬가지로 Category를 수정하고 싶은데, 이미 우리가 사용하는 모델과 이름이 겹쳐서 CategoryDetail로 변경했다.
그런데 CategoryDetail는 위와 다른 문제가 생긴다.
카테고리를 가져오는 공통된 코드가 존재한다는 점이다.
일단 이를 무시하고 나머지를 완성하면 아래처럼 될 것이다.
이때 url로 pk를 받아오므로 메소드에서도 pk를 사용한 것에 주의하자.

```python
# views.py
class CategoryDetail(APIView):
  """
  try:
    category = Category.objects.get(pk=pk)
  except Category.DoesNotExist:
    raise NotFound
  """
  def get(self, request, pk):
    serializer = CategorySerializer(category)
    return Response(serializer.data)

  def put(self, request, pk):
    serializer = CategorySerializer(
      category,
      data=request.data,
      partial=True,
    )

    if serializer.is_valid():
      updated_category = serializer.save()
      return Response(CategorySerializer(updated_category).data)
    else:
      return Response(serializer.errors)

  def delete(self, request, pk):
    category.delete()
    return Response(status=HTTP_204_NO_CONTENT)
```

문제는 주석으로 처리한 부분이다.
위 코드는 get, put, delete 모든 메소드에서 공통적으로 사용되어야 하는 부분이다.
그렇지만 클래스로 만들었기 때문에 단순히 위에 코드를 적는 것만으론 동작하지 않는다.
처음 떠올릴 수 있는 방법은 모든 메소드 앞에 복사해주는 것이지만, 코드를 수정할때마다 번거로울 것이다.
제일 쉬운 해결책은 새로운 메소드를 만들어서 이를 실행하는 것이다.
이때 관습적으로 이름은 get_object를 사용한다.
get_object 메소드는 pk로 검색을 하고 그 값을 반환하도록 만든다.
그리고 category를 self.get_object(pk)로 대체하면 된다.

```python
# views.py
class CategoryDetail(APIView):
    def get_object(self, pk):
        try:
            return Category.objects.get(pk=pk)
        except Category.DoesNotExist:
            raise NotFound

    def get(self, request, pk):
        serializer = CategorySerializer(self.get_object(pk))  # category -> self.get_object(pk)
        return Response(serializer.data)

    def put(self, request, pk):
        serializer = CategorySerializer(
            self.get_object(pk),  # category -> self.get_object(pk)
            data=request.data,
            partial=True,
        )
        if serializer.is_valid():
            updated_category = serializer.save()
            return Response(CategorySerializer(updated_category).data)
        else:
            return Response(serializer.errors)

    def delete(self, request, pk):
        self.get_object(pk).delete()  # category -> self.get_object(pk)
        return Response(status=HTTP_204_NO_CONTENT)
```

#### ModelSerializer

지금까지 serializer를 만들기 위해 꽤 많은 노력을 해왔다.
그런데 작성하는 내용을 보면 모델과 굉장히 많은 내용이 겹친다.
필드를 지정하고, 어떤 데이터 타입이 들어갈지, 제한 사항이 무엇인지 등은 모두 모델과 동일하게 만들어야 한다.
REST Framework는 이 때문에 모델만 가지고 serializer를 만들 수 있도록 했다.
serializer.py 파일로 이동해서 아래처럼 작성한다.

```python
# serializer.py
class CategorySerializer(serialisers.ModelSerializer):  # Serializer -> ModelSerializer
  class Meta:
    model = Category
```

여기다가 어떤 필드가 포함될지 지정해줘야 하는데, 방법은 2가지가 있다.
첫 번째는 포함될 필드를 지정하는 방법으로 fields를 사용한다.
아래처럼 사용하면 name과 kind 필드만 노출되고, pk와 created_at은 숨겨질 것이다.

```python
# serializer.py
class CategorySerializer(serialisers.ModelSerializer):  # Serializer -> ModelSerializer
  class Meta:
    model = Category
    fields = ("name", "kind")
```

만약 모든 내용이 노출되길 원하면 "\_\_all\_\_"을 사용한다.

```python
# serializer.py
class CategorySerializer(serialisers.ModelSerializer):  # Serializer -> ModelSerializer
  class Meta:
    model = Category
    fields = "__all__"
```

두 번째 방법은 제외될 내용을 지정하는 것인데, exclude로 지정한다.

```python
# serializer.py
class CategorySerializer(serialisers.ModelSerializer):  # Serializer -> ModelSerializer
  class Meta:
    model = Category
    exclude = ("pk", "created_at")
```

위처럼 작성하면 serializer은 완성된다.
지금까지 만들었던 create, update, 필드 지정등은 사실 필요 없는 일이었다.
그럼에도 불구하고 소개한 이유는 바로 ModelSerializer로 해결하면 그 사이의 작동 원리를 이해할 수 없기 때문이다.
왜 serializer에 매개변수를 넘겨줘야 하는지 직접해보지 않으면 이해할 수 없다.
다른 이유는 간혹 serializer를 커스텀으로 만들 필요가 있기 때문이다.
다만 대부분의 프로젝트는 ModelSerializer를 사용하는 것만으로 충분할 것이다.

#### ModelViewSet

views.py 파일에서 우리는 HTTP method에 따라 데이터를 처리했었다.
그런데 위와 같은 일은 대부분의 데이터에서 동일하게 일어나는 일이다.
REST Framework는 이 때문에 커스텀 클래스를 만들어뒀는데, 이를 사용하면 지금까지 한 일을 간단하게 처리할 수 있다.
우선 views.py 파일로 이동한 다음 rest_framework.viewsets에서 ModelViewSet을 가져온다.
클래스에는 serializer와 대상을 지정해줘야 하는데, 각각 우리가 작성한 serializer와 모델을 적어주면 된다.

```python
# views.py
from rest_framework.viewsets import ModelViewSet

class CategoryViewSet(ModelViewSet):
  serializer_class = CategorySerializer
  queryset = Category.objects.all()
```

이제 GET, POST 등의 메소드는 모두 urls.py 파일에 작성하면 된다.
해야할 것은 각 URL에서 method에 따라 어떤 일을 할지다.
list는 모든 항목을 보여주고, create는 항목을 생성하며, retrieve나 update 등은 pk에 맞는 단일 항목을 찾아 수정해준다.

```python
# views.py
urlpatterns = [
    path(
        "",
        views.CategoryViewSet.as_view(
            {
                "get": "list",
                "post": "create",
            }
        ),
    ),
    path(
        "<int:pk>",
        views.CategoryViewSet.as_view(
            {
                "get": "retrieve",
                "put": "partial_update",
                "delete": "destroy",
            }
        ),
    ),
]
```

이때 주의할 것은 단일 항목을 찾을 때, 이름을 pk로 해줘야 한다는 점이다.
retrieve 등은 코드 내에서 pk를 받아서 사용한다.
그러므로 url의 <int:pk>가 <int:category_pk>처럼 바뀌면 제대로 동작하지 않는다.
사용할 수 있는 리스트를 보려면 [routers](https://www.django-rest-framework.org/api-guide/routers/)에서 API Guide 항목을 읽어보자.
