---
title: Instagram2
date: 2022-11-21 10:01:23
category: CloneCoding
tag: [Javascript, React, Python, Django]
series: Create Instagram with React and Django
excerpt: ""
cover_image: /images/posts/networking.jpg
draft: true
---

## Settings before start

터미널을 열어서 `mkdir instagram-clone-backend`로 폴더를 만든다.
그 후 폴더를 열어서 git init으로 깃을 시작한다.

### Poetry installation

[Poetry](https://python-poetry.org/docs/)에서 설치 방법을 찾을 수 있는데, 터미널에 `curl -sSL https://install.python-poetry.org | python3 -`를 입력한다.
설치가 되었는지 확인하기 위해 `poetry`를 입력한다.
명령어가 나오면 제대로 설치된 것이다.
여기서 나는 *zsh: command not found: poetry*라는 오류가 발생했었다.
이는 zsh가 poetry의 위치를 모르기 때문에 발생하는 문제다.
우선 poetry 파일 위치를 알 필요가 있다.
나는 ~/.local/bin에 poetry 파일이 있었다.
위 경로를 ~/.zshrc 파일에 추가해줘야 하는데, 제일 아랫줄에 `export PATH=$HOME/.local/bin:$PATH`를 추가한다.
다시 poetry를 입력하면 poetry가 정상적으로 작동한다.

poetry를 사용하는 이유는 파이썬 가상환경을 만들기 위해서다.
가상환경이 무엇인지 잠시 설명하겠다.
파이썬을 사용하다보면 패키지를 설치해서 사용한다.
그런데 프로젝트마다 패키지를 설치하다보면 서로 다른 버전을 사용해서 문제가 생기기도 한다.
예를 들어서 현재 프로젝트는 django 4.0으로 만들었는데, 이후에 django가 5.0으로 업데이트 되면 작동하지 않는 기능이 생기게 된다.
이처럼 pip를 사용해 패키지를 사용하면 패키지 버전 관리가 어려워진다.
그래서 각 프로젝트마다 개별적인 공간을 만드는데, 이를 가상환경이라고 한다.
가상환경은 패키지를 로컬하게 설치해주므로 각 프로젝트마다 독립적으로 패키지를 사용할 수 있게 된다.
이로 인해 현재 프로젝트에 설치한 패키지가 다른 프로젝트에 영향을 줄 일이 없고, 앞처럼 버전관리로 고생하지 않아도 된다.

`poetry init`으로 poetry 사용을 시작하면 몇 가지 질문이 나온다.
아래처럼 입력하면 된다.

```
>>> poetry init

This command will guide you through creating your pyproject.toml config.

Package name [instagram-clone-backend]:
Version [0.1.0]:
Description []:
Author [Sangho <istrangeho@gmail.com>, n to skip]:
License []:   MIT
Compatible Python versions [^3.9]:

Would you like to define your main dependencies interactively? (yes/no) [yes] no
Would you like to define your development dependencies interactively? (yes/no) [yes] no
Generated file
...
Do you confirm generation? (yes/no) [yes] yes
```

파일을 보면 pyproject.toml이라는 파일이 생성되었다.
그 안에는 우리 프로젝트의 설명이 적혀있고, 사용하는 패키지가 적혀있다.
이제 이 안에 django를 설치해야 하는데 `poetry add django`로 설치할 수 있다.
설치 후에 pyproject.toml 파일을보면 django가 추가되었다.
그리고 poetry.lock 파일이 생성되었는데, 그 안에는 각 패키지의 버전 정보가 적혀있다.
poetry는 install 명령어로 필요한 패키지를 다운받을 수 있는데, 이때 패키지의 최신 버전을 다운 받는다.
그런데 패키지 버전이 달라지면 프로젝트가 작동하지 않을 수 있으므로 poetry.lock 파일에 패키지의 정보를 고정해놓는다.

pyproject.toml과 poetry.lock 파일이 왜 필요한지 좀 더 자세히 설명해보겠다.
프로젝트는 여러 사람이 동시에 진행하므로 같은 버전의 패키지를 사용해야 한다.
pyproject.toml엔 패키지 버전 등이 담겨있지만 패키지간의 의존성은 전혀 설명하지 않는다.
의존성을 적어둘 다른 파일로 poetry.lock를 만든 것이다.
그러므로 깃허브에 배포할 때 pyproject.toml과 poetry.lock 파일을 같이 배포해야만 한다.
만약 poetry.lock 파일을 빼고 배포하면, poetry는 pyproject.toml 파일을 기반으로 새로운 poetry.lock을 만든다.
이때 pyproject.toml에 적힌 프로젝트의 의존성 패키지를 최신 버전으로 설치해서 의존성에 문제가 생긴다.

앞으로 우리가 하는 작업은 poetry 내에서 실행되는 것이다.
그러므로 명령어를 입력하기 전에 `poetry shell`을 입력해야 한다.
그 후 `django-admin`을 입력하면 django-admin의 명령어가 나타난다.
poetry를 종료시키려면 `exit`을 입력하면 된다.

## start project

`poetry shell`, `django-admin startproject config .`으로 현재 위치에 프로젝트를 시작한다.
그러면 config 폴더가 생긴다.
현재까지 폴더 내용은 아래처럼 되어야 한다.

```
config/
    __init__.py
    asgi.py
    settings.py
    urls.py
    wsgi.py
manage.py
poetry.lock
pyproject.toml
```

각 파일이 어떤 경우에 사용되는지는 이후에 차차 배울 것이다.
이제 gitignore 파일을 추가해줘야 하는데, vscode의 익스텐션으로 간단하게 해결할 수 있다.
gitignore이라는 익스텐션을 검색해 설치한다.
그 후 설정 > command palette > add gitignore > python으로 gitignore 파일을 만든다.

## run server

앞서 프로젝틀를 시작하며 만든 파일 중에서 manage.py 파일이 있었다.
manage.py는 django에서 필요한 온갖 기능을 적어둔 파일로, 우리는 대부분의 기능을 이 파일을 실행해서 구현한다.
예를 들어 서버를 시작하거나, 애플리케이션을 만들거나, 변경 내용을 적용하는 등의 대부분의 기능이 이 파일에 만들어져 있다.
다른 기능은 이후에 소개하기로 하고 일단은 서버를 실행하려면 `python manage.py runserver`를 입력한다.
그러면 \_pycache\_라는 폴더와 db.sqlite3 파일이 생성된다.
콘솔을 보면 서버를 "http://127.0.0.1:8000/"에 실행시키고 있다.

```
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).

You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
December 05, 2022 - 06:25:21
Django version 4.1.3, using settings 'config.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```

메세지를 보면 18개의 마이그레이션이 적용되지 않았다는 에러가 보일 것이다.
이는 이후에 배울 것이고 일단은 넘어간다.

## MVC(Model View Controller)

우리가 만드는 대부분의 애플리케이션은 데이터를 시각적으로 보여주는 일을 한다.
오래전부터 사람들은 저장된 데이터를 사용자에게 보여주는 애플리케이션을 만들어왔고 그 과정에서 공통된 패턴을 발견한다.
이를 MVC 패턴이라고 하며 MVC에 따르면 코드는 데이터를 담당하는 코드, 사용자에게 보이는 부분, 앞의 둘을 조작하는 코드 3가지로 나뉜다.
이들은 각각 Model, View, Controller라고 불린다.

- Model: 데이터 담당
- View: 사용자에게 보이는 시각적 부분 담당
- Controller: Model과 View 사이의 흐름을 담당

왜 이렇게 3개로 나뉘게 되었는지 조금 생각해보자.
데이터를 저장, 삭제, 수정하기 위한 부분인 Model과 사용자에게 보이는 View가 있어야 한다는 것은 쉽게 알 수 있다.
그런데 애플리케이션이 동작하려면 Model에서 데이터를 읽어와 View로 보여줘야 한다.
이렇게 데이터를 읽어와 보여주는 코드는 눈으로 보이는 부분이 아니니 View는 아니다.
또한 이 코드가 저장된 데이터가 아니므로 Model이라고 할 수 없다.
이 코드의 특징은 View와 Model 사이에 존재하며 사용자 명령을 받아 Model을 수정하거나, 반대로 Model의 정보를 읽어와 View에 보여준다는 것이다.
그러므로 View와 Model을 조작한다는 의미에서 Controller라고 이름 붙인게 아닐까 한다.

MVC를 검색해보면 View가 Controller에 의존적이어선 안 된다거나, View는 Model에 의존적일 수 있다는 설명을 보곤한다.
의존적이라는 표현은 모호해서 이해하기 어려운데, 간단히 말해서 코드가 포함되어선 안 된다는 의미다.
각각의 의존관계는 아래와 같다.

- Model: View와 Controller에 의존하지 않는다.
- View: Model에 의존적이고, Controller에는 의존하면 안 된다.
- Controller: Model과 View에 의존적이다.

위가 무슨 의미인지 아래 예를 보고 설명하겠다.

```java
// Model
public class User {
  private String name;
  private String password;
  private String location;

  public User(String name, String password, String location) {
    this.name = name;
    this.password = password;
    this.location = location;
  }

  ...
}

// View
public class View {
  public void showUser(User user) {
    System.out.printIn(
      "User name is " + user.name
    )
  }
}

// Controller
public class Controller {
  public static void main(String[] args) {
    User user = new User("Alice", "abcde", "seoul");
    View.showUser(user);
  }
}
```

위 예시를 보면 Model은 View나 Controller의 내용을 사용하지 않는다.
Model은 순수하게 자기 자신에 관한 일만 다루고 있고, Model과 View의 코드를 포함하지 않는다.
다음으로 View를 보면 Model에 있는 사용자 정보를 가져와서 출력해준다.
View는 Model의 코드를 포함하고 있고, Controller의 코드는 없다.
마지막으로 Controller는 Model과 View의 코드를 둘 다 사용하고 있다.
이 관계를 그림으로 표현하면 아래처럼 된다.

```
    Model
  ↙       ↘
View  →   Controller
```

위 그림은 코드의 포함 관계만을 나타낸 것으로 흐름과는 관계 없다.
Model이 View에서 사용되긴 하지만, 코드상 직접적으로 가져와서 사용하진 않는다.
대신에 Controller에서 양쪽을 불러와서 일을 처리한다.
MVC가 동작하는 순서는 아래처럼 표시할 수 있다.

```
╔═════════════╗            ╔════════════════ Web Server ═════════════╗
║             ║            ║                                         ║
║             ║            ║                          //============ 3 ==========\\
║             ║            ║ +------------+           || +-------+   ║   +----+  ||
║             ║            ║ |            | --- 2 --> || | Model | <---> | DB |  ||
║             ║  --- 1 --> ║ |            | <-- 4 --- || +-------+   ║   +----+  ||
║ Web Browser ║            ║ |            |           \\=============║===========//
║             ║            ║ | Controller |                          ║
║             ║  <-- 7 --- ║ |            |            +------+      ║
║             ║            ║ |            | --- 5 -->  | View |      ║
║             ║            ║ |            | <-- 6 ---  |      |      ║
║             ║            ║ +------------+            +------+      ║
║             ║            ║                                         ║
╚═════════════╝            ╚═════════════════════════════════════════╝
```

1. 웹 브라우저에서 서버에 요청을 보내고, 서버는 요청에 맞는 컨트롤러를 선택한다.
2. 컨트롤러는 모델을 호출한다.
3. 모델은 객체를 생성하거나, DB에서 불러온다.
4. 결과값을 컨트롤러에 돌려준다.
5. 모델로부터 받은 값을 View에게 전달한다.
6. View는 값을 바탕으로 출력 결과를 만들어서 컨트롤러에게 돌려준다.
7. 서버는 웹 브라우저에게 요청값을 전달하고, 브라우저는 이를 화면에 표시한다.

## MTV(Model Template View)

django는 MVC 패턴 대신 MTV 패턴을 사용한다.
둘은 큰 틀에서 닮았는데 View를 Template으로 Controller는 View로 대체하면 비슷한 역할을 한다.
하지만 둘이 정확히 같은 구조는 아니다.
예를 들어서 도서관 백엔드를 만든다고 하자.
MVC 구조는 Controller가 데이터베이스에서 책 정보를 불러오고 View에게 건낸다.
View에서 보여줄 정보를 만든 다음 Controller에게 돌려준다.
Controller는 이를 URL과 결합시켜서 사용자에게 돌려준다.

django는 위처럼 데이터를 불러오거나, URL과 결합시키는 코드를 작성하지 않는다.
위 일들은 django 프레임워크가 대신하며, 단지 적절한 위치에 해야할 일을 적어주면 알아서 처리해준다.
좀 더 간단히 표현하자면 Controller에서 처리해야 할 일을 django가 맡고 있는 것이다.
django의 View와 Template는 MVC 패턴의 View를 나눈 것이라 생각할 수 있다.
MVC는 View에서 어떤 정보가 어떻게 보일지를 정했었다.
django는 이를 둘로 나눠서 어떤 정보가 보일지를 View에, 어떻게 보일지를 Template에 적도록 나눈 것이다.
요약하자면 django는 MVC 패턴에서 Controller가 할 일을 프레임워크가 대신하고 있다.
그리고 View의 일을 2개로 나눠서 View와 Template에 따로 작성하도록 만들었다.

왜 django가 MTV 패턴을 사용하는걸까?
이는 코드 작성이 더 쉽고, 수정하기 용이해서다.
django는 Controller가 해야 할 일을 대신해준다.
덕분에 해당 코드를 작성할 필요도 없고, View와 Model의 연결 관계가 좀 더 느슨해진다.
그래서 View에 코드를 쓰기 편하고, 또 변경 사항이 생겨도 어렵지 않게 수정할 수 있다.

## App 만들기

인스타그램엔 사용자, 댓글, 포스트 등 다양한 정보가 필요하다.
이때 이들을 한 파일에 만든다면 난잡해지므로, 주제별로 폴더를 만들게 된다.
각 폴더는 데이터를 정의하고, 조작하고, 보이는 방법을 정하게 된다.
예를 들어 사용자 폴더는 어떤 정보가 들어 있어야 하고, 사용자 정보를 어떻게 사용하며, 어떤 정보를 보여줄지 정한다.
이처럼 django는 주제별로 폴더를 나누게 되는데 이를 *앱*이라고 한다.
앱은 데이터 형태와 이를 조작하는 로직으로 구성되는데, 서로 다른 주제는 다른 앱에 작성되어야 한다.
그러므로 사용자, 댓글, 포스트는 각기 다른 앱에 작성된다.
처음에는 앱이 복잡해 보일 수도 있지만, 앱은 주제별로 폴더를 나눈 것에 불과하다.
앞으로 우리는 앱에 어떻게 모델을 만들고, 이들을 조작하는지 배울 것이다.

앱을 만들기 위해선 `python manage.py startapp users`로 테스트용 앱을 만든다.
폴더를 보면 아래처럼 구성된다.

```
users/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
```

앞으로 앱에서 model, view, template을 어떻게 만들지 배울 것이다.
자연스러운 순서는 모델부터 만드는 것인데, 문제는 모델부터 만들면 모델을 보여줄 페이지가 필요하단 것이다.
그래서 모델을 만들기 전에 admin 페이지를 설명하고 시작하겠다.

### Admin

django는 기본적으로 관리자 페이지가 존재한다.
`python manage.py runserver`로 서버를 실행시킨 다음 http://localhost:8000/admin/에 들어가면 로그인 창이 뜬다.
아직 우리는 관리자 계정을 만들지 않았으므로 로그인 할 수 없다.
admin 페이지에선 우리가 만든 모델을 볼 수 있다.

#### superuser

관리자 계정을 만들기 위해 `python manage.py createsuperuser`를 입력해야 한다.
그런데 우리는 아직 마이그레이션을 적용하지 않아, 관리자 계정을 만들 수 없다.
마이그레이션이 무엇인지는 뒤에 설명할 것인데, 일단은 `pyhton manage.py migrate`로 마이그레이션을 적용한다.
그 후 username, email, password를 입력해 계정을 만든다.
`python manage.py runserver`로 서버 실행한 후, /admin 페이지로 이동한다.
그리고 관리자 계정으로 로그인하면 된다.
django administration 페이지가 나오는데, 여기서 우리는 이후에 추가될 모델을 볼 수 있을 것이다.

def **str**(self)로 admin 페이지에서 보일 이름을 바꿔줄 수 있다.

list_display, list_filter, search_fields,
list 대신에 tuple로 정의하는 경우가 많음

### Model

django에서 모델을 만들려면 django.db.models.Model을 상속받아서 만들어야 한다.
각 모델은 models.py 안에 만들어주며 어떤 필드를 포함할지는 django.db.models 안에서 가져와서 사용한다.
아래는 사용자 모델을 만든 것이다.

```python
# users/models.py
from django.db import models

# Create your models here.

class User(models.Model):

  """ User definition for models"""

  name = models.CharField(max_length=30)
  email = models.CharField(max_length=50)
  description = models.TextField()
  join_date = models.DateTimeField("date published")

```

User 모델은 models.Model을 상속 받아 만들어진다.
이때 주석으로 어떤 내용인지 적어두는 것이 이후에 큰 도움이 된다.
모델은 필드 이름(name, email, join_date 등)을 적어줘야 하는데, 이는 엑셀의 column처럼 사용된다.
몇몇 필드는 인수를 반드시 필요로 하는데, 예를 들어 CharField는 max_length를 꼭 적어줘야 한다.
그 외에 default 같은 선택적인 변수가 있는데, 필요한 경우 django의 문서를 참고하자.

모델을 만들었으면 config/settings.py 파일에 모델을 등록해야 한다.
파일을 열어보면 INSTALLED_APPS가 있는데, 이 위치에 모델을 등록한다.

```python
# config/settings.py

INSTALLED_APPS = [
    ...
    'users.apps.UsersConfig',
]
```

이제 admin 페이지에서 위 내용을 확인해보겠다.
users/admin.py 파일로 이동해서 아래처럼 작성한다.

```python
# users/admin.py
from django.contrib import admin
from .models import User

# Register your models here.

@admin.register(User)
class UserAdmin(admin.ModelAdmin):
  pass
```

다시 admin 페이지에 들어가보면 Users라는 모델이 있다.
하지만 클릭해보면 에러메세지가 나오는데 이는 아직 마이그레이션을 적용하지 않았기 때문이다.

모델을 만들었으면 django에게 모델을 변경시킨 사실과, 이를 migration으로 저장하고 싶다는 것을 알려야 한다.
우선은 config/settings.py의 INSTALLED_APPS에 앱을 등록해야 한다.
우리는 이미 추가했으로 넘어간다.
그 다음 `python manage.py makemigrations users`로 django에게 이를 알린다.
그러면 아래처럼 메세지가 나온다.

```
Migrations for 'users':
  users/migrations/0001_initial.py
    - Create model User
```

django가 모델을 migration으로 저장하는데, 깃허브처럼 매번 버전을 migrations 폴더에 만들어둔다.
migraion에 어떤 내용이 있는지 보려면 `python manage.py sqlmigrate polls 0001` 명령을 입력한다.

```sql
BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" bigint NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
```

마이그레이션을 바탕으로 데이터베이스에 모델 테이블을 만들려면 `python manage.py migrate`를 실행한다.

```
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions, users
Running migrations:
  Applying users.0001_initial... OK
```

migrate는 마이그레이션을 실행하며, 모델의 변경 사항과 데이테베이스의 스키마의 동기화가 이뤄진다.

- models.py에서 모델을 변경
- python manage.py makemigrations 로 마이그레이션 제작
- python manage.py migrate 로 데이터베이스에 적용

이제 admin 페이지에서 Users를 추가할 수 있고, 각각 어떤 내용이 있는지 볼 수 있다.

ForeignKey 필드를 사용해 다른 모델을 가져올 수도 있다.
이때 ForeignKey로 가져온 모델이 삭제될경우 어떻게 해야할지 on_delete에 적어줘야 한다.

### View

```python
# polls/views.py
from django.http import HttpResponse

def index(request):
    return HttpResponse("This is polls")
```

View를 호출하려면 연결된 URL이 필요한데, URLconf로 이어준다.
urls.py라는 파일을 생성하고 아래처럼 작성한다.

```python
# polls/urls/py
from django.urls import path

from . import views

urlpatterns = [
  path("", views.index, name="index"),
]
```

다음으로 config 폴더의 urls.py를 열고 아래처럼 include 시킨다.

```python
# config/urls.py
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
  path("polls/", include("polls.urls")),
  path("admin/", admin.site.urls),
]
```

include는 다른 URLconf를 참조할 수 있도록한다.
django는 include를 만나면 URL에서 지금까지 일치하는 점은 잘라내고, 남은 문자열을 URLconf로 전달한다.

서버를 실행하고 페이지에 들어가면 View에서 작성한 내용이 보인다.

path는 route, view를 인수로 사용한다.
route에는 URL 패턴을 적고, 일치하는 패턴을 찾으면 view에 전달한다.

url에 변수를 포함하려면 <type:var>형태로 입력하면 된다.
예를 들어서 id를 정수값으로 사용하고 싶으면 <int:id>로 적어서 아래처럼 사용한다.

```python
# polls/urls.py
from django.urls import path

from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('<int:id>/', views.detail, name='detail'),

]
```

여기서 url에 적힌 변수는 view 파일에서 아래처럼 변수로 받아서 사용한다.

```python
# polls/views.py
def detail(request, id):
    return HttpResponse("You're looking at question %s." % id)
```

### Databases

config/settings.py 파일엔 django 설정을 위한 변수가 저장되어 있다.
django는 기본적으로 SQLite를 사용하도록 만들어져 있다.
다른 데이터베이스를 사용하고 싶다면 [DATABASES](https://docs.djangoproject.com/ko/4.1/ref/databases/#third-party-notes) 페이지를 보고 바꾸면 된다.

INSTALLED_APPS에 활성화된 모든 애플리케이션이 적혀있다.
처음에는 admin, auth, session 등의 기본적인 애플리케이션만 적혀있다.
이 중에는 데이터베이스 테이블을 사용하는 경우가 있어서, 테이블을 만들어줘야 정상적으로 작동한다.
`python manage.py migrate`
migrate 명령은 INSTALLED_APPS에 적힌 앱들의 데이터베이스 테이블을 생성한다.

앱을 INSTALLED_APPS에 추가하려면 아래처럼 적어준다.

```python
# config/settings.py
INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```

### Template

django를 DB관리와 API 용으로 사용하고, 프론트는 React로 만들 생각이라면 이 항목은 읽지 않아도 된다.
Template는 django에서 HTML로 페이지를 만들게 해준다.
이때 정적인 부분만 Template로 만들고 동적인 부분은 View에서 만들어 기능과 디자인을 구분해야 편하게 만들 수 있다.
polls 폴더에 templates 폴더를 만들고 polls.html 파일에 아래처럼 적어준다.

```python
# polls/templates/polls.html
{% if latest_question_list %}
    <ul>
    {% for question in latest_question_list %}
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}
```

위 코드를 보면 짐작하겠지만 HTML과 파이썬 코드를 혼용하고 있다.
이때 파이썬 코드는 {%%} 안에 적어줘야 하는데, 일반적인 파이썬 코드와 달리 {% endfor %}처럼 for문이 종료되는 위치를 적어줘야 한다.
간단하게 말해 HTML의 태그가 열리고 닫히듯이 파이썬 코드를 사용해야 한다는 의미다.

이제 위에서 만든 파일을 View에서 보여주려고 한다.
loader를 사용하는 방법과 render를 사용하는 방법이 있는데 각각의 장단점이 있다.

#### loader

django.template.loader를 사용해서 페이지를 불러올 수 있다.
이때 사용하는 변수는 context 내에 적어준다음 render에 전달해줘야 한다.

```python
# polls/views.py
from django.http import HttpResponse
from django.template import loader

from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    template = loader.get_template('polls.html')
    context = {
        'latest_question_list': latest_question_list,
    }
    return HttpResponse(template.render(context, request))
```

#### render

그런데 위처럼 Template를 사용하는 방법은 꽤나 자주 사용되므로, 좀 더 간결하게 render만으로 페이지를 만들 수 있게 되어있다.
loader과 HttpResponse를 사용하지 않고 아래처럼 적어줘도 같은 페이지가 나온다.

```python
# polls/views.py
from django.shortcuts import render

from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_question_list': latest_question_list}
    return render(request, 'polls/index.html', context)
```

보다시피 render이 훨씬 간결하고 보기 좋다.
그럼에도 HttpResponse의 속성을 사용해야할 경우엔 HttpResponse를 사용해야 한다.

보다시피 Template를 사용한 방법은 완전히 HTML로 만들어야 한다.
이는 물론 정적인 페이지나 간단한 결과를 보여주고 싶을 때, 사용하기 좋다.
그렇지만 대부분은 Template를 사용하지 않는다.
대신 React로 프론트 작업을 한다음 API로 django와 연결하는 방법을 많이 사용한다.

## Django REST Framework

Django REST Frmawork는 REST API를 쉽게 만들게 해준다.
REST API가 무엇인지는 이미 다른 포스트에 정리했으므로 넘어가겠다.
그런데 왜 REST API가 필요한 것일까?
앞서 우리는 Template를 만들어서 웹 페이지를 보여주는 방식을 배웠다.
간단한 페이지는 이렇게 HTML로 만들기 쉽지만, 좀 더 복잡한 페이지에선 React를 사용하길 원한다.
그렇다면 django는 HTML 대신에 필요한 정보를 JSON으로 전달해줘야 하고, 이는 곧 API를 사용해야 한다는 의미다.
프론트 앱에서 서버 API에 데이터를 요청하고 이를 바탕으로 페이지를 그리게 만들어줄 것이다.

`poetry i djangorestframework`

```python
# config/settings.py
INSTALLED_APPS = [
  ...
  'rest_framework',
]
```

### serializer
